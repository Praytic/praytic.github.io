# Java SE (Standart Edition)

### 1. Общее

1. **JRE (Java Runtime Environment)** — минимальная реализация виртуальной машины, необходимая для исполнения Java-приложений, без компилятора и других средств разработки. Включает в себя:
    - Виртуальную машину — Java Virtual Machine
    - Библиотеки Java-классов.

2. **JDK (Java Development Kit)** — бесплатно распространяемый компанией Oracle Corporation (ранее Sun Microsystems) комплект разработчика приложений на языке Java. Он включает в себя:
    - Компилятор Java (javac)
    - Стандартные библиотеки классов Java
    - Примеры, документацию, различные утилиты
    - Исполнительную систему Java (JRE).

3. **JVM (Java Virtual Machine)** — виртуальная машина Java — основная часть JRE. 
    - Виртуальная машина Java интерпретирует Байт-код Java, предварительно созданный из исходного текста Java-программы компилятором Java (javac). 
    - JVM может также использоваться для выполнения программ, написанных на других языках программирования.
    - HotSpot - основная JVM для настольных компьютеров и серверов, выпускаемая корпорацией Oracle.

4. **Байт-код** — набор инструкций, исполняемых виртуальной машиной Java. 
    - Для обеспечения кроссплатформенности программа сначала компилируется в промежуточный язык низкого уровня — байт-код. 
    - Если выполнение байт-кода на JVM нежелательно, исходный код на языке Java или Java байт-код может быть скомпилирован напрямую в нативный машинный код.
 
5. **Динамическая компиляция JIT (Just In Time)** -  технология увеличения производительности программных систем, использующих байт-код, путём компиляции байт-кода в машинный код или в другой формат непосредственно во время работы программы. Большинство реализаций JIT имеют последовательную структуру: 
    - Сначала приложение компилируется в байт-код виртуальной машины среды исполнения (AOT-компиляция).
    - Потом JIT компилирует байт-код непосредственно в машинный код.
    - В итоге при запуске приложения тратится лишнее время, что, впоследствии, компенсируется более быстрой его работой.

6. **Garbage Collector** - одна из форм автоматического управления памятью. 
    - Все объекты к которым невозможно добраться с корневых точек будут считаться мусором. 
    - HotSpot VM использует именно такой подход. 
    - Память освобождается сборщиком мусора по его собственному "усмотрению"

***

### 2. Элементы

1. **Пакет** - это именованная логическая группа классов. Пакеты непосредственно соответствуют иерархии в файловой системе.

2. **Импортирование имен** - способ ссылки на классы из другого пакета. При импортировании простое имя типа погружается в текущую область видимости имён, и его можно использовать непосредственно, без указания имени пакета.

3. **Класс** — это описания структуры и поведения объектов. Классы записываются программистом в виде исходного кода и компилируются в байт-код. Имея байт-код классов, виртуальная машина способна создавать объекты и обеспечивать вызов их методов.

4. **Объекты** — это участки памяти виртуальной машины, содержащие своё состояние в виде полей.

5. **Метод** — это просто функция, которая неявным параметром принимает объект, на котором она вызывается. Таким образом, отправка сообщения сводится к вызову функции.

6. **Абстрактный класс** — это такой класс, часть функционала которого не реализована, но задекларирована.

7. **Интерфейс** в Java можно понимать как класс, содержащий только абстрактные методы. Интерфейс предназначен для описания абстракций или контрактов, которые должен предоставлять класс, реализующий этот интерфейс.

8. **Функция** — именованный блок кода, возможно, принимающий некоторые данные извне (параметры/аргументы) и, возможно, возвращающий некоторый результат.

9. **Виртуальные методы** — такие методы, которые обладают свойством позднего связывания. 
    - В Java все методы виртуальные.

10. **Вложенный класс** — используется для более тонкой организации классов, чем с помощью пакетов. 
    - Существует несколько типов вложенных классов: вложенные статические, внутренние, анонимные, локальные. 
    - Вложенными могут быть также интерфейсы, перечисления и аннотации.
 
11. **Лямбда-выражение** — часть парадигмы функционального программирования. Предназначены для замены слишком многословного синтаксиса анонимных классов.

12. **Перечисление** — специальный тип данных, предусмотренный для ограничения множества допустимых значений для некоторого типа данных.

13. **Конструктор** — это специальный метод, который автоматически вызывается при создании объекта и инициализирует его состояние. 
    - Конструктор по умолчанию не создаётся, если в классе объявлен явно другой конструктор.

14. **Дженерики** — реализация обобщенного программирования, включающая в себя поддержку обобщенных классов и обобщенных методов. 
    - В первую очередь дженерики были нужны для создания типобезопасной библиотеки коллекций, т.е. с проверкой типов на этапе компиляции, а не в рантайме.

15. **Итератор** - объект, предоставляющий доступ к элементам коллекции и навигацию по ним. 
    - Каждый класс коллекций наследуется от интерфейса Iterable. 
    - Существуют 2 типа итераторов: Iterator и ListIterator. Второй наследуется от первого и предоставляет больше методов.

16. **Аннотации** - дескрипторы, включаемые в текст программы. Используются для хранения метаданных программного кода, необходимых на разных этапах жизненного цикла программы.
    - Пример определения аннотации.
    ```Java
    import java.lang.annotation.*;
    @Target(value=ElementType.FIELD)
    @Retention(value= RetentionPolicy.RUNTIME)
    public @interface Name {
        String name();
        String type() default  “string”;
    }
    ```
    
17. **Shadowing** - сокрытие объявления может произойти, когда объявляется ещё одна сущность того же рода с тем же именем в более узкой области видимости. В таком случае к исходной сущности нельзя обращаться по простому имени.

18. **Obscuring** может произойти, когда существует неоднозначность имени между разными пространствами имён (например, имя переменной совпадает с именем пакета). Такое случается крайне редко.

19. **Hiding** - скрытие имен происходит во время наследования, если в родительском и дочернем классе есть одинаковые статические методы.
    - Пример сокрытия:
    ```Java
    public class Test {
        public static void testClassMethod() {
        }
    }
    public class StandartTest extends Test {
        public static void testClassMethod() {
        }
    }
    ```

20. **Overriding** - процесс перегрузки метода, который происходит во время наследования, если в дочернем классе есть одинаковые нестатические методы.
    - Переруженный метод в Java принято помечать аннотацией @Override.
    - Пример перегрузки:
    ```Java
    public class Test {
        public void testInstanceMethod() {
        }
    }
    public class StandartTest extends Test {
        public void testInstanceMethod() {
        }
    }
    ```

21. **Исключение** - ошибка, возникающая во время выполнения программы.
    - Исключения в Java разделяются на checked, unchecked и errors.
    - Пример метода, который выбрасывает исключение.
    ```Java
    public class App {
        public static void main(String[] args) throws Throwable {}
    }
    ```
    - Пример метода, который обрабатывает исключение.
    ```Java
    public class App {
        public static void main(String[] args) {
            try {
            } catch (Throwable t) {}
        }
    }
    ```

***

### 3. ООП

1. **ООП (Объектно Ориентированное Программирование)** - методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы в свою очередь образуют иерархию наследования.

2. **Инкапсуляция** - сокрытие реализации.
    - Реализуется с помощью модификаторов видимости: default, public, protected, private.

3. **Полиморфизм** - парадигма ООП. Существует несколько его разновидностей:
    - **Ad-hoc (ситуативный) полиморфизм** — функция по-разному работает с данными разных типов из заранее фиксированного набора. Реализуется с помощью перегрузки методов.
    - **Параметрический полиморфизм** — функция работает одинаково с данными произвольных типов. Реализуется с помощью дженериков и параметризованных классов. 
    - **Полиморфизм подтипов** — функция работает одинако-во с данными типов, являющихся подтипами одного общего супер-типа, редоставляющего общий интерфейс. Реализуется с помощью наследования и иерархии классов.
    - **Динамический полиморфизм** — то, какой метод (из суперкласса или из подкласса) будет вызван, зависит от настоящего типа объекта, т.е. от того, объект какого класса на самом деле содержится в переменной. Реализуется с помощью позднего связыванания.

4. **Наследование** - возможность создавать потомков и переопределять часть функциональности класса.
    - Реализуется с помощью ключевого слова extends.
    - Java не поддерживает множественное наследование.

5. **Абстракция** - это выделение общих характеристик объекта, отличая от всех других объектов.
    - Реализуется с помощью абстрактных классов и интерфейсов.

6. **Класс** — это описания структуры и поведения объектов.

7. **Объекты** — это участки памяти виртуальной машины, содержащие своё состояние в виде полей.

***

### 4. Базовые конструкции

1. **Типы данных** - в Java существует два типа данных: примитивные и ссылочные:
    - Примитивные типы: `byte`, `short`, `int`, `float`, `double`, `long`, `boolean`, `char`.
    - Ссылочные типы: обертки примитивных типов, объекты классов, массивы.

2. **Операции** - операции в Java разделяются на следующие группы:
    - Арифметические операции: `+`, `-`, `/`, `*`, `%`, `++`, `--`.
    - Сравнительные операции: `==`, `!=`, `>`, `>=`, `<=`, `<`.
    - Побитовые операции: `&`, `|`, `^`, `~`, `<<`, `>>`, `>>>`.
    - Логические операции: `&&`, `||`, `!`.
    - Операции присваивания: `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `<<=`, `>>=`, `&=`, `^=`, `|=`.
    - Прочие операции: `() ? () : ()`, `instanceof`

3. **Строка** - последовательность символов, в Java строки являются объектами.
    - Строки в Java неизменяемы (immutable), для таких целей используется StringBuilder.
    - Форматированная строка выглядит следующим образом: `"Variable field: %s"` За место `%s` в строку вставляется переменная определенного типа.

4. **Массив** - фиксированная структура данных.
    - Массивы в Java объявляются следующим образом: 
    ```Java
    dataType[] arrayRefVar = new dataType[arraySize];
    dataType[] arrayRefVar = {value0, value1, ..., valueK};
    ```
    - Также существует Arrays класс, который предоставляет статические методы для манипуляций с массивами, такие как: 
    ```Java
    public static int binarySearch(Object[] a, Object key)
    public static boolean equals(long[] a, long[] a2)
    public static void fill(int[] a, int val)
    public static void sort(Object[] a)
    ```

***
    
### 5. Модификаторы

1. **`private`** (переменные / конструкторы / методы / внутренние классы) - члены класса доступны только внутри класса.
 
2. **`package-private`** или **`default`** (переменные / конструкторы / методы / классы) - члены класса видны внутри пакета.

3. **`protected`** (переменные / методы / конструкторы / внутренние классы) - члены класса доступны внутри пакета и в классах-наследника.

4. **`public`** (все) - члены класса доступны всем.

5. **`static`** (логические блоки / переменные / методы / классы) - статические блоки выполняются во время загрузки класса. К статическим методам и переменным можно обращаться через имя класса. 

6. **`abstract`** (методы / классы) - абстрактные классы должны наследоваться, а абстрактные методы - реализовываться.

7. **`final`** (переменные / методы / классы) - переменные, которым было присвоино значение, не могут быть переприсвоены. Методы не могут быть перегруженны. Классы не могут быть наследованы.

8. **`synchronized`** (методы / части метода) - метод может одновременно использоваться только одним потоком.
 
9. **`transient`** (переменные) - переменная не сериализуется. Локальные переменные не могут быть объявлены как transient. 

10. **`volatile`** (переменные) - значение переменной, объявленной как volatile, измененное одним потоком, асинхронно меняется и для других потоков. 

11. **`native`** (методы) - обозначает, что метод написан на другом языке программирования.
 
12. **`strictfp`** (методы / классы) - обеспечивает выполнение операций над числами типа float и double (с плавающей запятой) по стандарту IEEE 754.

***

### 6. Дженерики

1. **Дженерики** — реализация обобщенного программирования, включающая в себя поддержку обобщенных классов и обобщенных методов. 

2. **Обобщенные классы** - обобщенные (параметризованные) классы могут использоваться для следующих целей:
    - Коллекции и контейнеры: `List<Integer>`, `Set<Long>`, `Map<String, Runnable>`, `Future<HttpResponse>`, `Optional<Model>`.
    - Компараторы
    ```Java
    public interface Comparator<T> {
        int compare(T left, T right);
    }
    ```
    - Объекты-команды
    ```Java
    public interface Function<F, T> {
        T apply(F arg);
    }
    public interface Callable<T> {
        T call() throws Exception;
    }
    ```
    - Провайдеры
    ```Java
    public interface Provider<T> {
        T get();
    }
    public interface ThrowingProvider<T, E extends Throwable> {
        T get() throws E;
    }
    ```
    - Обобщенные DAO
    ```Java
    public abstract class GenericDAO<T, ID> {
        protected GenericDAO(Class<T> clazz) { ... }
        public T findById(ID id) { ... }
    }
    ```
    - Конверторы
    ```Java
    public interface StringConverter<T> {
        T fromString(String s);
        String toString(T obj);
    }
    ```
    - Кортежи
    ```Java
    public class TwoTuple<A,B> { 
        public final A first; 
        public final B second; 
        public TwoTuple(A a, B b) { 
            first = a; second = b; 
        }
    }
    ```

3. **Обобщенные методы** - обобщенные (параметризованные) методы могут использоваться для следующих целей:
    - Обобщенные фабричные методы:
    ```Java
    public static <T extends Enum<T>> EnumSet<T> allOf(Class<T> clazz);
    public static <T> ImmutableList<T> of(T pɴ, T pɵ, T... other);
    public <T> T getInstance(Key<T> key);
    ```
    - Методы-преобразователи
    ```Java
    public static <T> Iterable<T> skip(Iterable<T> iterable, int n);
    public static <F, T> Iterable<T> transform(Iterable<F> iterable, Function<F, T> function);
    ```
    - Обобщенные утилитные методы
    ```Java
    public static <T extends Comparable<T>> T max(Iterable<T> xs);
    ```
    
4. **Wildcards** - обобщенные (параметризованные) методы могут использоваться для следующих целей:
    - Wildcards with upper bound:
    ```Java
    public static double sumOfList(List<? extends Number> list);
    ```
    - Unbounded wildcard
    ```Java
    void printCollection(Collection<?> c);
    ```
    - Wildcards with lower bound
    ```Java
    public static void addNumbers(List<? super Integer> list);
    ```
    
### 7. Многопоточность

1. **Многопоточность** - это когда множество процессов делят общие вычислительные ресурсы, такие как CPU, между собой.
    - Многопотчная программа содержит 2 или более частей, который могут работать одновременно, и каждая часть может выполнять свое действие, тем самым создавая оптимальные условия для использования доступных ресурсов.
    - Многопоточность расширяет идею многозадачности в приложениях, где можно разделить определенные операции в индивидуальные потоки.
    - Операционная система разделяет вычислительное время не только между различными программами, но и между потоками этих приложений.

2. **Поток** в Java представлен классом `java.lang.Thread`, объекты которого являются потоками, работающими внутри текущей JVM. 
    - Каждый поток может работать параллельно.
    - Начиная с версии 1.5 в состав стандартной библиотеки Java входит пакет `java.util.concurrent`, в котором содержится большое количество различных классов, помогающих при разработке многопоточных программ.

3. **Создание потока**. Для того, чтобы выполнить какую-либо задачу в отдельном потоке, можно создать новый поток с помощью конструктора класса `Thread`, передать ему `Runnable` и запустить его.
    - Пример создания потока:
    ```Java
    new Thread(new Runnable() {
        @Override public void run() { /* ... */ }
    }).start();
    new Thread(() -> { /* ... */ }).start();
    ```
    
4. **Создание сервисного потока**. Выполнение Java-машины завершается, когда завершатся все потоки, не являющиеся сервисными, т.е. те, у которых не установлен флаг daemon.
    - Пример создания сервисного потока:
    ```Java
    Thread t = new Thread(() -> { ... });
    t.setDaemon(true);
    t.start();
    ```
    
5. **Критические секции**. При работе потоков с общей изменяемой памятью неизбежно возникает проблема синхронизации действий этих потоков. 
    - Самым простым способом упорядочить работу потоков с общими данными являются `synchronized-блоки`.

6. **synchronized-блоками**  обозначаются критические секции — участки кода, которые в каждый момент времени могут выполняться только одним потоком. 
    - Синхронизация потоков всегда происходит с использованием какого-либо объекта. 
    - Поток, входящий в synchronized-блок, захватывает монитор, связанный с объектом этого блока.
    - Пример создания synchronized-блока:
    ```Java
    private static final Object lock = new Object();
    private static void transfer(int amount) {
        synchronized (lock) {
            account1 = account1 - amount;
            account2 = account2 + amount;
        }
    }
    ```
    
7. **Замки** - являются более мощной версией synchronized-блока. Основные интерфейсы замков — `java.util.concurrent.locks.Lock` и `ReadWriteLock`, а наиболее полезные классы — `ReentrantLock` и `ReentrantReadWriteLock`.
    - Пример создания замка:
    ```Java
    private static final Lock lock = new ReentrantLock();
    lock.lock();
    try {
        // критическая секция
    } 
    finally { 
        lock.unlock(); 
    }
    ```
    
7. **Пулы потоков** - это набор потоков, которым можно передавать какие-либо задачи (например, Runnable) на выполнение. 
    - Создание потока — дорогая операция, и часто большинство задач выполняются недолго. Поэтому имеет смысл переиспользовать уже созданные потоки для  различных задач. 
    - Пример создания пула потоков:
    ```Java
    Executor executor = Executors.newFixedThreadPool(4);
    executor.execute(() -> /* ... */ );
    executor.execute(new Runnable() {
        @Override public void run() { /* ... */ } 
    });
    ```
    
8. **Жизненный цикл потока**. Поток проходит через несколько стадий своего жизненного цикла:
    - New - новый поток начинает свой жизненный цикл с изначального состояния. Он остается в нем до тех пор, пока программа не запустит его.
    - Runnable - после того, как поток создался, его надо запустить, в связи с чем, он перейдет в данное состояние. Поток в таком состоянии уже выполняет свои функции.
    - Waiting - иногда переходы между потоками занимают некоторое время, во время которого поток находится в таком состоянии, до тех пор, пока другой поток не переведет его в состояние runnable.
    - Timed waiting - runnable поток может установить время ожидания для какого-то события, после чего перейдет в данное состояние. Он перейдет обратно в runnable только после того, как истечет указанное время, или если событие, которого он ждет, произойдет.
    - Terminated - runnable поток завершается после выполнения своих функций (или его завершают) и переходит в данное состояние.
    - Диаграмма жизненого цикла потока:
    ![Диаграмма жизненого цикла потока](http://www.tutorialspoint.com/java/images/Thread_Life_Cycle.jpg)

9. **Приоритет** - каждый поток имеет приоритет, который помогает операционной системе распознавать порядок в котором потоки будут работать: `MIN_PRIORITY`, `NORM_PRIORITY`, `MAX_PRIORITY`.
