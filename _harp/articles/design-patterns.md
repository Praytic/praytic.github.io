# Design Patterns

### 1. Общее

1. **Паттерн** или **шаблон проектирования** - повторимая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.

### 2. Creational Patterns

1. **Abstract Factory** (Абстрактная фабрика) - предоставляет интерфейс для создания групп связанных или зависимых объектов, не указывая их конкретный класс.

1. **Factory Method** (Фабричный метод) - определяет интерфейс для создания объекта, но позволяет подклассам решать, какой класс инстанцировать. Позволяет делегировать создание объекта подклассам.

1. **Builder** (Строитель) - разделяет создание сложного объекта и инициализацию его состояния так, что одинаковый процесс построения может создать объекты с разным состоянием.

1. **Prototype** (Прототип) - определяет несколько видов объектов, чтобы при создании использовать объект-прототип и создает новые объекты, копируя прототип.
  - Примером реализации в Java данного паттерна является метод `java.util.Object.clone()`.

1. **Singleton** (Одиночка) - гарантирует, что класс имеет только один экземпляр и предоставляет глобальную точку доступа к нему.

### 3. Structural Patterns

1. **Adapter** (Адаптер) - конвертирует интерфейс класса в другой интерфейс, ожидаемый клиентом. Позволяет классам с разными интерфейсами работать вместе.

1. **Proxy** (Прокси) - предоставляет замену другого объекта для контроля доступа к нему.

1. **Bridge** (Мост) - разделяет абстракцию и реализацию так, чтобы они могли изменяться независимо.

1. **Composite** (Компоновщик) - компонует объекты в дреновидную структуру, представляя их в виде иерархии. Позволяет клиенту одинакового обращаться как к отдельному объекту, так и к целому поддереву.

1. **Decorator** (Декоратор) - динамически предоставляет объекту дополнительные возможности. Представляет собой гибкую альтернативу наследованию для расширения функциональности.

1. **Facade** (Фасад) - предоставляет единый интерфейс к группе интерфейсов подсистемы. Определяет высокоуровневый интерфейс, делая подсистему проще для использования.

1. **Flyweight** (Приспособленец, Легковесная) - благодаря совместному использованию, поддерживает эффективную работу с большим количеством объектов. Его суть заключается в том, что тяжеловесный объект, представляющий себя как уникальный экземпляр в разных местах программы, по факту не является таковым.
  - Примером является старая реализация `java.lang.String`, где тяжеловсным объектом является массив charов, а все условные копии данной строки ссылаются на него-же. Таким образом методы вроде `java.lang.String.substring()` работали быстро, так как достаточно было только передвинуть указатели и отображать кусок от всей строки. От такой реализации отказались, так как она могла привести к утечке памяти.

### 4. Behavioral Patterns

1. **Memento** (Хранитель) - не нарушая инкапсуляцию, определяет и сохраняет внутреннее состояние объекта и позволяет позже восстановить объект в этом состоянии.

1. **Chain of responsibility** (Цепочка обязанностей) - избегает связывания отправителя запроса с его получателем, давая возможность обработать запрос более чем одному объекту. Связывает объекты-получатели и передает запрос по цепочке, пока объект не обработает его.

1. **Observer** (Наблюдатель) - определяет зависимость "один ко многим" между объектами так, что когда один объект меняет свое состояние, все зависимые объекты оповещаются и обновляются автоматически.

1. **Command** (Команда) - инкапсулирует запрос в виде объекта, позволяя передавать их клиентам в качестве параметров, ставить в очередь, логировать, а также поддерживает отмену операций.

1. **State** (Состояние) - позволяет объекту менять свое поведение в зависимости от внутреннего состояния.

1. **Interpreter** (Интерпретатор) - получая формальный язык, определяет представление его грамматики и интерпретатор, использующий это представление для обработки выражений языка.

1. **Strategy** (Стратегия) - определяет группу алгоритмов, инкапсулирует их и делает взаимозаменяемыми. Позволяет изменять алгоритм независимо от клиентов, его использующих.

1. **Iterator** (Итератор) - предоставляет способ последовательного доступа к элементам множества, независимо от его внутренного устройства.

1. **Template method** (Шаблонный метод) - определяет алгоритм, некоторые этапы которого делегируются подклассам. Позволяет подклассам переопределить эти этапы, не меняя структуру алгоритма.

1. **Mediator** (Посредник) - определяет объект, инкапсулирующий способ взаимодействия объектов. Обеспечивает слабую свзяь, избавляя объекты от необходимости прямо ссылаться друг на друга и дает возможность независимо изменять их взаимодействие.

1. **Visitor** (Посетитель) - представляет собой операцию, которая будет выполнена над объектами группы классов. Дает возможность определить новую операцию без изменения кода классов, над которыми эта операция проводится.
  - Примером этого паттерна является работа javac компилятора.

### 5. MVC

1. **MVC (Model-View-Controller)** - схема использования нескольких шаблонов проектирования, с помощью которых модель приложения, пользовательский интерфейс и взаимодействие с пользователем разделены на три отдельных компонента таким образом, чтобы модификация одного из компонентов оказывала минимальное воздействие на остальные.

### 6. MVP

1. **MVP (Model-View-Presenter)** - шаблон проектирования, производный от MVC, который используется в основном для построения пользовательского интерфейса. Элемент Presenter в данном шаблоне берёт на себя функциональность посредника (аналогично контроллеру в MVC) и отвечает за управление событиями пользовательского интерфейса так же, как в других шаблонах обычно отвечает представление.

### 7. MVVM

1. **MVVM (Model-View-ViewModel)** - шаблон проектирования, производный от MVP, который используется для разделения модели и её представления, что необходимо для изменения их отдельно друг от друга. Например, разработчик задает логику работы с данными, а дизайнер соответственно работает с пользовательским интерфейсом.
