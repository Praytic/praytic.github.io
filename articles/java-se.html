<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><title></title><meta name="description" content="undefined"/><meta name="author" content="undefined"/><meta name="handheldfriendly" content="true"/><meta name="mobileoptimized" content="320"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="cleartype" content="on"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><link rel="stylesheet" href="/css/style.css"/><link rel="stylesheet" href="/css/github-markdown.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/styles/default.min.css"/></head><body class="wrapper"><header><div class="container"><h2 class="lone-header">Knowledge Library 1.0</h2></div></header><section><div class="container"><ul class="docs-nav"><li><strong><a href="/">Оглавление</a></strong></li><li><a href="/articles/web-service">Web Service</a></li><li><a href="/articles/java-se">Java SE</a></li></ul><div class="docs-content markdown-body"><h1>Java SE (Standart Edition)</h1><h3>1. Общее</h3><ol>
<li><p><strong>JRE (Java Runtime Environment)</strong> — минимальная реализация виртуальной машины, необходимая для исполнения Java-приложений, без компилятора и других средств разработки. Включает в себя:</p>
<ul>
<li>Виртуальную машину — Java Virtual Machine</li>
<li>Библиотеки Java-классов.</li>
</ul>
</li>
<li><p><strong>JDK (Java Development Kit)</strong> — бесплатно распространяемый компанией Oracle Corporation (ранее Sun Microsystems) комплект разработчика приложений на языке Java. Он включает в себя:</p>
<ul>
<li>Компилятор Java (javac)</li>
<li>Стандартные библиотеки классов Java</li>
<li>Примеры, документацию, различные утилиты</li>
<li>Исполнительную систему Java (JRE).</li>
</ul>
</li>
<li><p><strong>JVM (Java Virtual Machine)</strong> — виртуальная машина Java — основная часть JRE. </p>
<ul>
<li>Виртуальная машина Java интерпретирует Байт-код Java, предварительно созданный из исходного текста Java-программы компилятором Java (javac). </li>
<li>JVM может также использоваться для выполнения программ, написанных на других языках программирования.</li>
<li>HotSpot - основная JVM для настольных компьютеров и серверов, выпускаемая корпорацией Oracle.</li>
</ul>
</li>
<li><p><strong>Байт-код</strong> — набор инструкций, исполняемых виртуальной машиной Java. </p>
<ul>
<li>Для обеспечения кроссплатформенности программа сначала компилируется в промежуточный язык низкого уровня — байт-код. </li>
<li>Если выполнение байт-кода на JVM нежелательно, исходный код на языке Java или Java байт-код может быть скомпилирован напрямую в нативный машинный код.</li>
</ul>
</li>
<li><p><strong>Динамическая компиляция JIT (Just In Time)</strong> -  технология увеличения производительности программных систем, использующих байт-код, путём компиляции байт-кода в машинный код или в другой формат непосредственно во время работы программы. Большинство реализаций JIT имеют последовательную структуру: </p>
<ul>
<li>Сначала приложение компилируется в байт-код виртуальной машины среды исполнения (AOT-компиляция).</li>
<li>Потом JIT компилирует байт-код непосредственно в машинный код.</li>
<li>В итоге при запуске приложения тратится лишнее время, что, впоследствии, компенсируется более быстрой его работой.</li>
</ul>
</li>
<li><p><strong>Garbage Collector</strong> - одна из форм автоматического управления памятью. </p>
<ul>
<li>Все объекты к которым невозможно добраться с корневых точек будут считаться мусором. </li>
<li>HotSpot VM использует именно такой подход. </li>
<li>Память освобождается сборщиком мусора по его собственному &quot;усмотрению&quot;</li>
</ul>
</li>
</ol>
<hr>
<h3>2. Элементы</h3><ol>
<li><p><strong>Пакет</strong> - это именованная логическая группа классов. Пакеты непосредственно соответствуют иерархии в файловой системе.</p>
</li>
<li><p><strong>Импортирование имен</strong> - способ ссылки на классы из другого пакета. При импортировании простое имя типа погружается в текущую область видимости имён, и его можно использовать непосредственно, без указания имени пакета.</p>
</li>
<li><p><strong>Класс</strong> — это описания структуры и поведения объектов. Классы записываются программистом в виде исходного кода и компилируются в байт-код. Имея байт-код классов, виртуальная машина способна создавать объекты и обеспечивать вызов их методов.</p>
</li>
<li><p><strong>Объекты</strong> — это участки памяти виртуальной машины, содержащие своё состояние в виде полей.</p>
</li>
<li><p><strong>Метод</strong> — это просто функция, которая неявным параметром принимает объект, на котором она вызывается. Таким образом, отправка сообщения сводится к вызову функции.</p>
</li>
<li><p><strong>Абстрактный класс</strong> — это такой класс, часть функционала которого не реализована, но задекларирована.</p>
</li>
<li><p><strong>Интерфейс</strong> в Java можно понимать как класс, содержащий только абстрактные методы. Интерфейс предназначен для описания абстракций или контрактов, которые должен предоставлять класс, реализующий этот интерфейс.</p>
</li>
<li><p><strong>Функция</strong> — именованный блок кода, возможно, принимающий некоторые данные извне (параметры/аргументы) и, возможно, возвращающий некоторый результат.</p>
</li>
<li><p><strong>Виртуальные методы</strong> — такие методы, которые обладают свойством позднего связывания. </p>
<ul>
<li>В Java все методы виртуальные.</li>
</ul>
</li>
<li><p><strong>Вложенный класс</strong> — используется для более тонкой организации классов, чем с помощью пакетов. </p>
<ul>
<li>Существует несколько типов вложенных классов: вложенные статические, внутренние, анонимные, локальные. </li>
<li>Вложенными могут быть также интерфейсы, перечисления и аннотации.</li>
</ul>
</li>
<li><p><strong>Лямбда-выражение</strong> — часть парадигмы функционального программирования. Предназначены для замены слишком многословного синтаксиса анонимных классов.</p>
</li>
<li><p><strong>Перечисление</strong> — специальный тип данных, предусмотренный для ограничения множества допустимых значений для некоторого типа данных.</p>
</li>
<li><p><strong>Конструктор</strong> — это специальный метод, который автоматически вызывается при создании объекта и инициализирует его состояние. </p>
<ul>
<li>Конструктор по умолчанию не создаётся, если в классе объявлен явно другой конструктор.</li>
</ul>
</li>
<li><p><strong>Дженерики</strong> — реализация обобщенного программирования, включающая в себя поддержку обобщенных классов и обобщенных методов. </p>
<ul>
<li>В первую очередь дженерики были нужны для создания типобезопасной библиотеки коллекций, т.е. с проверкой типов на этапе компиляции, а не в рантайме.</li>
</ul>
</li>
<li><p><strong>Итератор</strong> - объект, предоставляющий доступ к элементам коллекции и навигацию по ним. </p>
<ul>
<li>Каждый класс коллекций наследуется от интерфейса Iterable. </li>
<li>Существуют 2 типа итераторов: Iterator и ListIterator. Второй наследуется от первого и предоставляет больше методов.</li>
</ul>
</li>
<li><p><strong>Аннотации</strong> - дескрипторы, включаемые в текст программы. Используются для хранения метаданных программного кода, необходимых на разных этапах жизненного цикла программы.</p>
<ul>
<li>Пример определения аннотации.<pre><code class="language-Java">import java.lang.annotation.*;
@Target(value=ElementType.FIELD)
@Retention(value= RetentionPolicy.RUNTIME)
public @interface Name {
  String name();
  String type() default  “string”;
}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Shadowing</strong> - сокрытие объявления может произойти, когда объявляется ещё одна сущность того же рода с тем же именем в более узкой области видимости. В таком случае к исходной сущности нельзя обращаться по простому имени.</p>
</li>
<li><p><strong>Obscuring</strong> может произойти, когда существует неоднозначность имени между разными пространствами имён (например, имя переменной совпадает с именем пакета). Такое случается крайне редко.</p>
</li>
<li><p><strong>Hiding</strong> - скрытие имен происходит во время наследования, если в родительском и дочернем классе есть одинаковые статические методы.</p>
<ul>
<li>Пример сокрытия:<pre><code class="language-Java">public class Test {
  public static void testClassMethod() {
  }
}
public class StandartTest extends Test {
  public static void testClassMethod() {
  }
}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Overriding</strong> - процесс перегрузки метода, который происходит во время наследования, если в дочернем классе есть одинаковые нестатические методы.</p>
<ul>
<li>Переруженный метод в Java принято помечать аннотацией @Override.</li>
<li>Пример перегрузки:<pre><code class="language-Java">public class Test {
  public void testInstanceMethod() {
  }
}
public class StandartTest extends Test {
  public void testInstanceMethod() {
  }
}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Исключение</strong> - ошибка, возникающая во время выполнения программы.</p>
<ul>
<li>Исключения в Java разделяются на checked, unchecked и errors.</li>
<li>Пример метода, который выбрасывает исключение.<pre><code class="language-Java">public class App {
  public static void main(String[] args) throws Throwable {}
}
</code></pre>
</li>
<li>Пример метода, который обрабатывает исключение.<pre><code class="language-Java">public class App {
  public static void main(String[] args) {
      try {
      } catch (Throwable t) {}
  }
}
</code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<h3>3. ООП</h3><ol>
<li><p><strong>ООП (Объектно Ориентированное Программирование)</strong> - методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы в свою очередь образуют иерархию наследования.</p>
</li>
<li><p><strong>Инкапсуляция</strong> - сокрытие реализации.</p>
<ul>
<li>Реализуется с помощью модификаторов видимости: default, public, protected, private.</li>
</ul>
</li>
<li><p><strong>Полиморфизм</strong> - парадигма ООП. Существует несколько его разновидностей:</p>
<ul>
<li><strong>Ad-hoc (ситуативный) полиморфизм</strong> — функция по-разному работает с данными разных типов из заранее фиксированного набора. Реализуется с помощью перегрузки методов.</li>
<li><strong>Параметрический полиморфизм</strong> — функция работает одинаково с данными произвольных типов. Реализуется с помощью дженериков и параметризованных классов. </li>
<li><strong>Полиморфизм подтипов</strong> — функция работает одинако-во с данными типов, являющихся подтипами одного общего супер-типа, редоставляющего общий интерфейс. Реализуется с помощью наследования и иерархии классов.</li>
<li><strong>Динамический полиморфизм</strong> — то, какой метод (из суперкласса или из подкласса) будет вызван, зависит от настоящего типа объекта, т.е. от того, объект какого класса на самом деле содержится в переменной. Реализуется с помощью позднего связыванания.</li>
</ul>
</li>
<li><p><strong>Наследование</strong> - возможность создавать потомков и переопределять часть функциональности класса.</p>
<ul>
<li>Реализуется с помощью ключевого слова extends.</li>
<li>Java не поддерживает множественное наследование.</li>
</ul>
</li>
<li><p><strong>Абстракция</strong> - это выделение общих характеристик объекта, отличая от всех других объектов.</p>
<ul>
<li>Реализуется с помощью абстрактных классов и интерфейсов.</li>
</ul>
</li>
<li><p><strong>Класс</strong> — это описания структуры и поведения объектов.</p>
</li>
<li><p><strong>Объекты</strong> — это участки памяти виртуальной машины, содержащие своё состояние в виде полей.</p>
</li>
</ol>
<hr>
<h3>4. Базовые конструкции</h3><ol>
<li><p><strong>Типы данных</strong> - в Java существует два типа данных: примитивные и ссылочные:</p>
<ul>
<li>Примитивные типы: <code>byte</code>, <code>short</code>, <code>int</code>, <code>float</code>, <code>double</code>, <code>long</code>, <code>boolean</code>, <code>char</code>.</li>
<li>Ссылочные типы: обертки примитивных типов, объекты классов, массивы.</li>
</ul>
</li>
<li><p><strong>Операции</strong> - операции в Java разделяются на следующие группы:</p>
<ul>
<li>Арифметические операции: <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>%</code>, <code>++</code>, <code>--</code>.</li>
<li>Сравнительные операции: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&lt;</code>.</li>
<li>Побитовые операции: <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>.</li>
<li>Логические операции: <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>.</li>
<li>Операции присваивания: <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>^=</code>, <code>|=</code>.</li>
<li>Прочие операции: <code>() ? () : ()</code>, <code>instanceof</code></li>
</ul>
</li>
<li><p><strong>Строка</strong> - последовательность символов, в Java строки являются объектами.</p>
<ul>
<li>Строки в Java неизменяемы (immutable), для таких целей используется StringBuilder.</li>
<li>Форматированная строка выглядит следующим образом: <code>&quot;Variable field: %s&quot;</code> За место <code>%s</code> в строку вставляется переменная определенного типа.</li>
</ul>
</li>
<li><p><strong>Массив</strong> - фиксированная структура данных.</p>
<ul>
<li>Массивы в Java объявляются следующим образом: <pre><code class="language-Java">dataType[] arrayRefVar = new dataType[arraySize];
dataType[] arrayRefVar = {value0, value1, ..., valueK};
</code></pre>
</li>
<li>Также существует Arrays класс, который предоставляет статические методы для манипуляций с массивами, такие как: <pre><code class="language-Java">public static int binarySearch(Object[] a, Object key)
public static boolean equals(long[] a, long[] a2)
public static void fill(int[] a, int val)
public static void sort(Object[] a)
</code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<h3>5. Модификаторы</h3><ol>
<li><p><strong><code>private</code></strong> (переменные / конструкторы / методы / внутренние классы) - члены класса доступны только внутри класса.</p>
</li>
<li><p><strong><code>package-private</code></strong> или <strong><code>default</code></strong> (переменные / конструкторы / методы / классы) - члены класса видны внутри пакета.</p>
</li>
<li><p><strong><code>protected</code></strong> (переменные / методы / конструкторы / внутренние классы) - члены класса доступны внутри пакета и в классах-наследника.</p>
</li>
<li><p><strong><code>public</code></strong> (все) - члены класса доступны всем.</p>
</li>
<li><p><strong><code>static</code></strong> (логические блоки / переменные / методы / классы) - статические блоки выполняются во время загрузки класса. К статическим методам и переменным можно обращаться через имя класса. </p>
</li>
<li><p><strong><code>abstract</code></strong> (методы / классы) - абстрактные классы должны наследоваться, а абстрактные методы - реализовываться.</p>
</li>
<li><p><strong><code>final</code></strong> (переменные / методы / классы) - переменные, которым было присвоино значение, не могут быть переприсвоены. Методы не могут быть перегруженны. Классы не могут быть наследованы.</p>
</li>
<li><p><strong><code>synchronized</code></strong> (методы / части метода) - метод может одновременно использоваться только одним потоком.</p>
</li>
<li><p><strong><code>transient</code></strong> (переменные) - переменная не сериализуется. Локальные переменные не могут быть объявлены как transient. </p>
</li>
<li><p><strong><code>volatile</code></strong> (переменные) - значение переменной, объявленной как volatile, измененное одним потоком, асинхронно меняется и для других потоков. </p>
</li>
<li><p><strong><code>native</code></strong> (методы) - обозначает, что метод написан на другом языке программирования.</p>
</li>
<li><p><strong><code>strictfp</code></strong> (методы / классы) - обеспечивает выполнение операций над числами типа float и double (с плавающей запятой) по стандарту IEEE 754.</p>
</li>
</ol>
<hr>
<h3>6. Дженерики</h3><ol>
<li><p><strong>Дженерики</strong> — реализация обобщенного программирования, включающая в себя поддержку обобщенных классов и обобщенных методов. </p>
</li>
<li><p><strong>Обобщенные классы</strong> - обобщенные (параметризованные) классы могут использоваться для следующих целей:</p>
<ul>
<li>Коллекции и контейнеры: <code>List&lt;Integer&gt;</code>, <code>Set&lt;Long&gt;</code>, <code>Map&lt;String, Runnable&gt;</code>, <code>Future&lt;HttpResponse&gt;</code>, <code>Optional&lt;Model&gt;</code>.</li>
<li>Компараторы<pre><code class="language-Java">public interface Comparator&lt;T&gt; {
  int compare(T left, T right);
}
</code></pre>
</li>
<li>Объекты-команды<pre><code class="language-Java">public interface Function&lt;F, T&gt; {
  T apply(F arg);
}
public interface Callable&lt;T&gt; {
  T call() throws Exception;
}
</code></pre>
</li>
<li>Провайдеры<pre><code class="language-Java">public interface Provider&lt;T&gt; {
  T get();
}
public interface ThrowingProvider&lt;T, E extends Throwable&gt; {
  T get() throws E;
}
</code></pre>
</li>
<li>Обобщенные DAO<pre><code class="language-Java">public abstract class GenericDAO&lt;T, ID&gt; {
  protected GenericDAO(Class&lt;T&gt; clazz) { ... }
  public T findById(ID id) { ... }
}
</code></pre>
</li>
<li>Конверторы<pre><code class="language-Java">public interface StringConverter&lt;T&gt; {
  T fromString(String s);
  String toString(T obj);
}
</code></pre>
</li>
<li>Кортежи<pre><code class="language-Java">public class TwoTuple&lt;A,B&gt; { 
  public final A first; 
  public final B second; 
  public TwoTuple(A a, B b) { 
      first = a; second = b; 
  }
}
</code></pre>
</li>
</ul>
</li>
</ol></div></div></section><section class="vibrant centered"><div><h4>This documentation provided by <a href="https://github.com/Praytic">Chernogorov Vladislav</a>.</h4></div></section></body><script src="//ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/highlight.min.js"></script><script src="/js/layout.js"></script><script type="text/javascript">hljs.initHighlightingOnLoad();</script></html>