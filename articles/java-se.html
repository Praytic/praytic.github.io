<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><title>Java Dev Lib</title><meta name="description" content="Солянка из теорий различных технологий, так или иначе связанных с разработкой или с Java. Большинство теории переведено с англоязычных ресурсов."/><meta name="author" content="Chernogorov Vladislav"/><meta name="handheldfriendly" content="true"/><meta name="mobileoptimized" content="320"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="cleartype" content="on"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><link rel="stylesheet" href="/css/style.css"/><link rel="stylesheet" href="/css/github-markdown.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/styles/default.min.css"/><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject'] = r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-75180616-1', 'auto');
ga('send', 'pageview');</script></head><body class="wrapper"><header><div class="container"><h2 class="lone-header">Java Dev Lib</h2></div></header><section><div class="container"><ul class="docs-nav"><li><strong><a href="/">Оглавление</a></strong></li><li><a href="/articles/web-service">Web Service</a></li><li><a href="/articles/java-se">Java SE</a></li><li><a href="/articles/java-ee">Java EE</a></li><li><a href="/articles/spring">Spring</a></li><li><a href="/articles/git">Git</a></li><li><a href="/articles/sql">SQL</a></li><li><a href="/articles/design-patterns">Design Patterns</a></li><hr/><li><a href="/articles/example">Example</a></li></ul><div class="docs-content markdown-body"><h1>Java SE (Standart Edition)</h1><h3>1. Общее</h3><ol>
<li><p><strong>JRE (Java Runtime Environment)</strong> — минимальная реализация виртуальной машины, необходимая для исполнения Java-приложений, без компилятора и других средств разработки. Включает в себя:</p>
<ul>
<li>Виртуальную машину — Java Virtual Machine</li>
<li>Библиотеки Java-классов.</li>
</ul>
</li>
<li><p><strong>JDK (Java Development Kit)</strong> — бесплатно распространяемый компанией Oracle Corporation (ранее Sun Microsystems) комплект разработчика приложений на языке Java. Он включает в себя:</p>
<ul>
<li>Компилятор Java (javac)</li>
<li>Стандартные библиотеки классов Java</li>
<li>Примеры, документацию, различные утилиты</li>
<li>Исполнительную систему Java (JRE).</li>
</ul>
</li>
<li><p><strong>JVM (Java Virtual Machine)</strong> — виртуальная машина Java — основная часть JRE. </p>
<ul>
<li>Виртуальная машина Java интерпретирует Байт-код Java, предварительно созданный из исходного текста Java-программы компилятором Java (javac). </li>
<li>JVM может также использоваться для выполнения программ, написанных на других языках программирования.</li>
<li>HotSpot - основная JVM для настольных компьютеров и серверов, выпускаемая корпорацией Oracle.</li>
</ul>
</li>
<li><p><strong>Байт-код</strong> — набор инструкций, исполняемых виртуальной машиной Java. </p>
<ul>
<li>Для обеспечения кроссплатформенности программа сначала компилируется в промежуточный язык низкого уровня — байт-код. </li>
<li>Если выполнение байт-кода на JVM нежелательно, исходный код на языке Java или Java байт-код может быть скомпилирован напрямую в нативный машинный код.</li>
</ul>
</li>
<li><p><strong>Динамическая компиляция JIT (Just In Time)</strong> -  технология увеличения производительности программных систем, использующих байт-код, путём компиляции байт-кода в машинный код или в другой формат непосредственно во время работы программы. Большинство реализаций JIT имеют последовательную структуру: </p>
<ul>
<li>Сначала приложение компилируется в байт-код виртуальной машины среды исполнения (AOT-компиляция).</li>
<li>Потом JIT компилирует байт-код непосредственно в машинный код.</li>
<li>В итоге при запуске приложения тратится лишнее время, что, впоследствии, компенсируется более быстрой его работой.</li>
</ul>
</li>
<li><p><strong>Garbage Collector</strong> - одна из форм автоматического управления памятью. </p>
<ul>
<li>Все объекты к которым невозможно добраться с корневых точек будут считаться мусором. </li>
<li>HotSpot VM использует именно такой подход. </li>
<li>Память освобождается сборщиком мусора по его собственному &quot;усмотрению&quot;</li>
</ul>
</li>
</ol>
<hr>
<h3>2. Элементы</h3><ol>
<li><p><strong>Пакет</strong> - это именованная логическая группа классов. Пакеты непосредственно соответствуют иерархии в файловой системе.</p>
</li>
<li><p><strong>Импортирование имен</strong> - способ ссылки на классы из другого пакета. При импортировании простое имя типа погружается в текущую область видимости имён, и его можно использовать непосредственно, без указания имени пакета.</p>
</li>
<li><p><strong>Класс</strong> — это описания структуры и поведения объектов. Классы записываются программистом в виде исходного кода и компилируются в байт-код. Имея байт-код классов, виртуальная машина способна создавать объекты и обеспечивать вызов их методов.</p>
<ul>
<li>Шаблон определения класса:<pre><code class="language-Java">[public] [final|abstract] class ClassName 
[extends OtherClass] 
[implements Interface1, Interface2] {}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Объекты</strong> — это участки памяти виртуальной машины, содержащие своё состояние в виде полей.</p>
<ul>
<li>Шаблон определения поля объекта:<pre><code class="language-Java">[public|protected|private] [static] [final] Type field;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Метод</strong> — это просто функция, которая неявным параметром принимает объект, на котором она вызывается. Таким образом, отправка сообщения сводится к вызову функции.</p>
<ul>
<li>Шаблон определения поля объекта:<pre><code class="language-Java">[public|protected|private] [static|abstract|final] Type method(Type param) {}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Абстрактный класс</strong> — это такой класс, часть функционала которого не реализована, но задекларирована.</p>
</li>
<li><p><strong>Интерфейс</strong> в Java можно понимать как класс, содержащий только абстрактные методы. Интерфейс предназначен для описания абстракций или контрактов, которые должен предоставлять класс, реализующий этот интерфейс.</p>
</li>
<li><p><strong>Функция</strong> — именованный блок кода, возможно, принимающий некоторые данные извне (параметры/аргументы) и, возможно, возвращающий некоторый результат.</p>
</li>
<li><p><strong>Виртуальные методы</strong> — такие методы, которые обладают свойством позднего связывания. </p>
<ul>
<li>В Java все методы виртуальные.</li>
</ul>
</li>
<li><p><strong>Вложенный класс</strong> — используется для более тонкой организации классов, чем с помощью пакетов. </p>
<ul>
<li>Существует несколько типов вложенных классов: вложенные статические, внутренние, анонимные, локальные. </li>
<li>Вложенными могут быть также интерфейсы, перечисления и аннотации.</li>
<li>Шаблон определения вложенного класса:<pre><code class="language-Java">[public|protected|private] [static] [abstract|final] class NestedClass {}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Лямбда-выражение</strong> — часть парадигмы функционального программирования. Предназначены для замены слишком многословного синтаксиса анонимных классов.</p>
<ul>
<li>Шаблон определения лямбда-выражения:<pre><code class="language-Java">(Type param) -&gt; { /* body */ }
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Перечисление</strong> — специальный тип данных, предусмотренный для ограничения множества допустимых значений для некоторого типа данных.</p>
<ul>
<li>Шаблон определения перечисления:<pre><code class="language-Java">[public] enum EnumName [implements Interface1, Interface2] {}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Конструктор</strong> — это специальный метод, который автоматически вызывается при создании объекта и инициализирует его состояние. </p>
<ul>
<li>Конструктор по умолчанию не создаётся, если в классе объявлен явно другой конструктор.</li>
<li>Шаблон определения конструктора:<pre><code class="language-Java">[public|protected|private] ClassName(Type param) {}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Дженерики</strong> — реализация обобщенного программирования, включающая в себя поддержку обобщенных классов и обобщенных методов. </p>
<ul>
<li>В первую очередь дженерики были нужны для создания типобезопасной библиотеки коллекций, т.е. с проверкой типов на этапе компиляции, а не в рантайме.</li>
<li>Пример определения дженериков:<pre><code class="language-Java">public class SomeClass&lt;T1, T2, ...&gt; {}
&lt;T1, T2, ..., E [extends|super] ClassName&gt; R method(T1 p1, T2 p2, ...) throws E {}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Итератор</strong> - объект, предоставляющий доступ к элементам коллекции и навигацию по ним. </p>
<ul>
<li>Каждый класс коллекций наследуется от интерфейса Iterable. </li>
<li>Существуют 2 типа итераторов: Iterator и ListIterator. Второй наследуется от первого и предоставляет больше методов.</li>
</ul>
</li>
<li><p><strong>Аннотации</strong> - дескрипторы, включаемые в текст программы. Используются для хранения метаданных программного кода, необходимых на разных этапах жизненного цикла программы.</p>
<ul>
<li>Пример определения аннотации.<pre><code class="language-Java">import java.lang.annotation.*;
@Target(value=ElementType.FIELD)
@Retention(value= RetentionPolicy.RUNTIME)
public @interface Name {
  String name();
  String type() default  “string”;
}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Shadowing</strong> - сокрытие объявления может произойти, когда объявляется ещё одна сущность того же рода с тем же именем в более узкой области видимости. В таком случае к исходной сущности нельзя обращаться по простому имени.</p>
</li>
<li><p><strong>Obscuring</strong> может произойти, когда существует неоднозначность имени между разными пространствами имён (например, имя переменной совпадает с именем пакета). Такое случается крайне редко.</p>
</li>
<li><p><strong>Hiding</strong> - скрытие имен происходит во время наследования, если в родительском и дочернем классе есть одинаковые статические методы.</p>
<ul>
<li>Пример сокрытия:<pre><code class="language-Java">public class Test {
  public static void testClassMethod() {
  }
}
public class StandartTest extends Test {
  public static void testClassMethod() {
  }
}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Overriding</strong> - процесс перегрузки метода, который происходит во время наследования, если в дочернем классе есть одинаковые нестатические методы.</p>
<ul>
<li>Переруженный метод в Java принято помечать аннотацией @Override.</li>
<li>Пример перегрузки:<pre><code class="language-Java">public class Test {
  public void testInstanceMethod() {
  }
}
public class StandartTest extends Test {
  public void testInstanceMethod() {
  }
}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Исключение</strong> - ошибка, возникающая во время выполнения программы. Исключения сигнализируют о возникновении ошибочной ситуации, из-за которой программа не может выполняться дальше. Поэтому исключения вызывают раскрутку стека вызовов. Когда какой-либо метод выбрасывает исключение, виртуальная машина начинает выталкивать элементы из стека вызовов (как будто произошёл возврат из каждого метода) до тех пор, пока не найдёт обработчик, который сможет обработать это исключение. Если такой обработчик нашёлся, то управление передаётся в него, и код внутри этого обработчика может либо продолжить выполнение программы, либо выбросить ещё одно исключение.</p>
<ul>
<li>Исключения в Java разделяются на checked, unchecked и errors.</li>
<li>Checked-исключения - наследники класса <code>Exception</code>. Метод обязан либо обработать эти исключения, либо явно объявить (с помощью декларации <code>throws</code>), что он их выбрасывает.</li>
<li>Uncheked-исключения - наследники класса <code>RuntimeException</code>. Их объявлять и отлавливать необязательно.</li>
<li>Специальные исключения (errors) - наследники класса <code>Error</code>, выбрасываемые виртуальной машиной в случае серьёзной ошибки (кончилась память, не удалось загрузить класс и т.д.). Обычный код не должен обрабатывать эти исключения.</li>
<li><code>try-with-resources</code>. В Java 7 была введена специальная конструкция, позволяющая безопасно открывать и закрывать ресурсы (классы, реализующие интерфейс <code>AutoCloseable</code>). </li>
<li>Пример метода, который выбрасывает исключение:<pre><code class="language-Java">public static void main(String[] args) throws Throwable {}
</code></pre>
</li>
<li>Пример метода, который обрабатывает исключение:<pre><code class="language-Java">public static void main(String[] args) {
  try {} 
  catch (Throwable t) {}
  finally {}
}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>JavaBeans</strong> - компоненты (бины), обеспечивающие основу для многократно используемых, встраиваемых и модульных компонентов ПО. Компоненты JavaBeans могут принимать различные формы, но наиболее широко они применяются в элементах графического пользовательского интерфейса. <sup><a href="https://ru.wikipedia.org/wiki/JavaBeans">[source]</a></sup></p>
<ul>
<li>Одна из целей создания JavaBeans — взаимодействие с похожими компонентными структурами.</li>
<li>Чтобы класс мог работать как bean, он должен соответствовать определённым соглашениям:<ul>
<li>Класс должен иметь конструктор без параметров, с модификатором доступа public. Такой конструктор позволяет инструментам создать объект без дополнительных сложностей с параметрами.</li>
<li>Свойства класса должны быть доступны через get, set и другие методы (так называемые методы доступа), которые должны подчиняться стандартному соглашению об именах. Это легко позволяет инструментам автоматически определять и обновлять содержание bean’ов. </li>
<li>Класс должен быть сериализуем. Это даёт возможность надёжно сохранять, хранить и восстанавливать состояние bean независимым от платформы и виртуальной машины способом.</li>
<li>Класс должен иметь переопределенные методы equals(), hashCode() и toString().</li>
</ul>
</li>
<li><p>Пример бина, как POJO объекта:</p>
<pre><code class="language-Java">public class PersonBean implements Serializable {
  private String name;

  public PersonBean() {
  }

  public String getName() {
     return (this.name);
  }
  public void setName(String name) {
     this.name = name;
  }

  @Override
  public boolean equals(Object o) {
      ...
  }
  @Override
  public int hashCode() {
      ...
  }
  @Override
  public String toString() {
      ...
  }
}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>POJO (Plain Old Java Object)</strong> - простой Java-объект, не унаследованный от какого-то специфического объекта и не  реализующий никаких служебных интерфейсов сверх тех, которые нужны для бизнес-модели. <sup><a href="https://ru.wikipedia.org/wiki/POJO">[source]</a></sup></p>
</li>
</ol>
<hr>
<h3>3. ООП</h3><ol>
<li><p><strong>ООП (Объектно Ориентированное Программирование)</strong> - методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы в свою очередь образуют иерархию наследования.</p>
</li>
<li><p><strong>Инкапсуляция</strong> - сокрытие реализации.</p>
<ul>
<li>Реализуется с помощью модификаторов видимости: <code>default</code>, <code>public</code>, <code>protected,</code> <code>private</code>.</li>
</ul>
</li>
<li><p><strong>Полиморфизм</strong> - парадигма ООП. Существует несколько его разновидностей:</p>
<ul>
<li><strong>Ad-hoc (ситуативный) полиморфизм</strong> — функция по-разному работает с данными разных типов из заранее фиксированного набора. Реализуется с помощью перегрузки методов.</li>
<li><strong>Параметрический полиморфизм</strong> — функция работает одинаково с данными произвольных типов. Реализуется с помощью дженериков и параметризованных классов. </li>
<li><strong>Полиморфизм подтипов</strong> — функция работает одинако-во с данными типов, являющихся подтипами одного общего супер-типа, редоставляющего общий интерфейс. Реализуется с помощью наследования и иерархии классов.</li>
<li><strong>Динамический полиморфизм</strong> — то, какой метод (из суперкласса или из подкласса) будет вызван, зависит от настоящего типа объекта, т.е. от того, объект какого класса на самом деле содержится в переменной. Реализуется с помощью позднего связыванания.</li>
</ul>
</li>
<li><p><strong>Наследование</strong> - возможность создавать потомков и переопределять часть функциональности класса.</p>
<ul>
<li>Реализуется с помощью ключевого слова extends.</li>
<li>Java не поддерживает множественное наследование классов.</li>
</ul>
</li>
<li><p><strong>Абстракция</strong> - это выделение общих характеристик объекта, отличая от всех других объектов.</p>
<ul>
<li>Реализуется с помощью абстрактных классов и интерфейсов.</li>
</ul>
</li>
<li><p><strong>Класс</strong> — это описание структуры и поведения объектов.</p>
</li>
<li><p><strong>Объекты</strong> — это участки памяти виртуальной машины, содержащие своё состояние в виде полей.</p>
</li>
</ol>
<hr>
<h3>4. Базовые конструкции</h3><ol>
<li><p><strong>Типы данных</strong> - в Java существует два типа данных: примитивные и ссылочные:</p>
<ul>
<li>Примитивные типы: <code>byte</code>, <code>short</code>, <code>int</code>, <code>float</code>, <code>double</code>, <code>long</code>, <code>boolean</code>, <code>char</code>.</li>
<li>Ссылочные типы: обертки примитивных типов, объекты классов, массивы.</li>
</ul>
</li>
<li><p><strong>Операции</strong> - операции в Java разделяются на следующие группы:</p>
<ul>
<li>Арифметические операции: <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>%</code>, <code>++</code>, <code>--</code>.</li>
<li>Сравнительные операции: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&lt;</code>.</li>
<li>Побитовые операции: <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>.</li>
<li>Логические операции: <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>.</li>
<li>Операции присваивания: <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>^=</code>, <code>|=</code>.</li>
<li>Прочие операции: <code>() ? () : ()</code>, <code>instanceof</code></li>
</ul>
</li>
<li><p><strong>Строка</strong> - последовательность символов, в Java строки являются объектами.</p>
<ul>
<li>Строки реализованы с помощью класса <code>String</code>.</li>
<li>Строки в Java неизменяемы (immutable) в целях безопасности, поэтому строки могут кэшировать свой хэшкод, что делает ее очень быстрой как ключ для <code>HashMap</code>. При том, строки могут свободно использоваться различными потоками, не боясь, что кто-то их изменит, таким образом отпадает необходимость в синхронизации.</li>
<li>Если строку нужно изменять, то следует использовать <code>StringBuilder</code> или <code>StringBuffer</code>.</li>
<li><code>StringTokenizer</code> - позволяет разбивать текст на лексемы, отделяемые разделителями. Парсит данные. Быстрый. Не поддерживает регулярные выражения. Устаревший.</li>
<li><code>String.split</code> - позволяет разбивать текст на лексемы, отделяемые разделителями. Поддерживает регулярные выражения. Возвращаемым значением является массив строк. Работает медленее, чем <code>StringTokenizer</code>.</li>
<li><code>Formatter</code> - обеспечивает преобразование формата, позволяющее выводить числа, строки, время и даты в любом необходимом разработчику виде.</li>
<li><code>Pattern</code> - применяется для определения регулярных выражений (шаблонов), для которых ищется соответствие в строке, файле или другом объекте, представляющем последовательность символов.</li>
<li><code>Matcher</code> - если необходимо найти соответствия внутри строки, необходимо использовать этот класс.</li>
</ul>
</li>
<li><p><strong>Массив</strong> - фиксированная структура данных.</p>
<ul>
<li>Массивы в Java объявляются следующим образом: <pre><code class="language-Java">dataType[] arrayRefVar = new dataType[arraySize];
dataType[] arrayRefVar = {value0, value1, ..., valueK};
</code></pre>
</li>
<li>Также существует Arrays класс, который предоставляет статические методы для манипуляций с массивами, такие как: <pre><code class="language-Java">public static int binarySearch(Object[] a, Object key)
public static boolean equals(long[] a, long[] a2)
public static void fill(int[] a, int val)
public static void sort(Object[] a)
</code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<h3>5. Модификаторы</h3><ol>
<li><p><strong><code>private</code></strong> (переменные / конструкторы / методы / внутренние классы) - члены класса доступны только внутри класса.</p>
</li>
<li><p><strong><code>package-private</code></strong> или <strong><code>default</code></strong> (переменные / конструкторы / методы / классы) - члены класса видны внутри пакета.</p>
</li>
<li><p><strong><code>protected</code></strong> (переменные / методы / конструкторы / внутренние классы) - члены класса доступны внутри пакета и в классах-наследника.</p>
</li>
<li><p><strong><code>public</code></strong> (все) - члены класса доступны всем.</p>
</li>
<li><p><strong><code>static</code></strong> (логические блоки / переменные / методы / классы) - статические блоки выполняются во время загрузки класса. К статическим методам и переменным можно обращаться через имя класса. </p>
</li>
<li><p><strong><code>abstract</code></strong> (методы / классы) - абстрактные классы должны наследоваться, а абстрактные методы - реализовываться.</p>
</li>
<li><p><strong><code>final</code></strong> (переменные / методы / классы) - переменные, которым было присвоино значение, не могут быть переприсвоены. Методы не могут быть перегруженны. Классы не могут быть наследованы.</p>
</li>
<li><p><strong><code>synchronized</code></strong> (методы / части метода) - метод может одновременно использоваться только одним потоком.</p>
</li>
<li><p><strong><code>transient</code></strong> (переменные) - переменная не сериализуется. Локальные переменные не могут быть объявлены как transient. </p>
</li>
<li><p><strong><code>volatile</code></strong> (переменные) - значение переменной, объявленной как volatile, измененное одним потоком, асинхронно меняется и для других потоков. </p>
</li>
<li><p><strong><code>native</code></strong> (методы) - обозначает, что метод написан на другом языке программирования.</p>
</li>
<li><p><strong><code>strictfp</code></strong> (методы / классы) - обеспечивает выполнение операций над числами типа float и double (с плавающей запятой) по стандарту IEEE 754.</p>
</li>
</ol>
<hr>
<h3>6. Дженерики</h3><ol>
<li><p><strong>Дженерики</strong> — реализация обобщенного программирования, включающая в себя поддержку обобщенных классов и обобщенных методов. </p>
</li>
<li><p><strong>Обобщенные классы</strong> - обобщенные (параметризованные) классы могут использоваться для следующих целей:</p>
<ul>
<li>Коллекции и контейнеры: <code>List&lt;Integer&gt;</code>, <code>Set&lt;Long&gt;</code>, <code>Map&lt;String, Runnable&gt;</code>, <code>Future&lt;HttpResponse&gt;</code>, <code>Optional&lt;Model&gt;</code>.</li>
<li>Компараторы<pre><code class="language-Java">public interface Comparator&lt;T&gt; {
  int compare(T left, T right);
}
</code></pre>
</li>
<li>Объекты-команды<pre><code class="language-Java">public interface Function&lt;F, T&gt; {
  T apply(F arg);
}
public interface Callable&lt;T&gt; {
  T call() throws Exception;
}
</code></pre>
</li>
<li>Провайдеры<pre><code class="language-Java">public interface Provider&lt;T&gt; {
  T get();
}
public interface ThrowingProvider&lt;T, E extends Throwable&gt; {
  T get() throws E;
}
</code></pre>
</li>
<li>Обобщенные DAO<pre><code class="language-Java">public abstract class GenericDAO&lt;T, ID&gt; {
  protected GenericDAO(Class&lt;T&gt; clazz) { ... }
  public T findById(ID id) { ... }
}
</code></pre>
</li>
<li>Конверторы<pre><code class="language-Java">public interface StringConverter&lt;T&gt; {
  T fromString(String s);
  String toString(T obj);
}
</code></pre>
</li>
<li>Кортежи<pre><code class="language-Java">public class TwoTuple&lt;A,B&gt; { 
  public final A first; 
  public final B second; 
  public TwoTuple(A a, B b) { 
      first = a; second = b; 
  }
}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Обобщенные методы</strong> - обобщенные (параметризованные) методы могут использоваться для следующих целей:</p>
<ul>
<li>Обобщенные фабричные методы:<pre><code class="language-Java">public static &lt;T extends Enum&lt;T&gt;&gt; EnumSet&lt;T&gt; allOf(Class&lt;T&gt; clazz);
public static &lt;T&gt; ImmutableList&lt;T&gt; of(T pɴ, T pɵ, T... other);
public &lt;T&gt; T getInstance(Key&lt;T&gt; key);
</code></pre>
</li>
<li>Методы-преобразователи<pre><code class="language-Java">public static &lt;T&gt; Iterable&lt;T&gt; skip(Iterable&lt;T&gt; iterable, int n);
public static &lt;F, T&gt; Iterable&lt;T&gt; transform(Iterable&lt;F&gt; iterable, Function&lt;F, T&gt; function);
</code></pre>
</li>
<li>Обобщенные утилитные методы<pre><code class="language-Java">public static &lt;T extends Comparable&lt;T&gt;&gt; T max(Iterable&lt;T&gt; xs);
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Wildcards</strong> - wildcards существуют трех типов:</p>
<ul>
<li>Wildcards with upper bound:<pre><code class="language-Java">public static double sumOfList(List&lt;? extends Number&gt; list);
</code></pre>
</li>
<li>Unbounded wildcard<pre><code class="language-Java">void printCollection(Collection&lt;?&gt; c);
</code></pre>
</li>
<li>Wildcards with lower bound<pre><code class="language-Java">public static void addNumbers(List&lt;? super Integer&gt; list);
</code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<h3>7. Многопоточность</h3><ol>
<li><p><strong>Многопоточность</strong> - это когда множество процессов делят общие вычислительные ресурсы, такие как CPU, между собой.</p>
<ul>
<li>Многопотчная программа содержит 2 или более частей, который могут работать одновременно, и каждая часть может выполнять свое действие, тем самым создавая оптимальные условия для использования доступных ресурсов.</li>
<li>Многопоточность расширяет идею многозадачности в приложениях, где можно разделить определенные операции в индивидуальные потоки.</li>
<li>Операционная система разделяет вычислительное время не только между различными программами, но и между потоками этих приложений.</li>
</ul>
</li>
<li><p><strong>Поток</strong> в Java представлен классом <code>java.lang.Thread</code>, объекты которого являются потоками, работающими внутри текущей JVM. </p>
<ul>
<li>Каждый поток может работать параллельно.</li>
<li>Начиная с версии 1.5 в состав стандартной библиотеки Java входит пакет <code>java.util.concurrent</code>, в котором содержится большое количество различных классов, помогающих при разработке многопоточных программ.</li>
</ul>
</li>
<li><p><strong>Создание потока</strong>. Для того, чтобы выполнить какую-либо задачу в отдельном потоке, можно создать новый поток с помощью конструктора класса <code>Thread</code>, передать ему <code>Runnable</code> и запустить его.</p>
<ul>
<li>Пример создания потока:<pre><code class="language-Java">new Thread(new Runnable() {
  @Override public void run() { /* ... */ }
}).start();
new Thread(() -&gt; { /* ... */ }).start();
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Создание сервисного потока</strong>. Выполнение Java-машины завершается, когда завершатся все потоки, не являющиеся сервисными, т.е. те, у которых не установлен флаг daemon.</p>
<ul>
<li>Пример создания сервисного потока:<pre><code class="language-Java">Thread t = new Thread(() -&gt; { ... });
t.setDaemon(true);
t.start();
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Критические секции</strong>. При работе потоков с общей изменяемой памятью неизбежно возникает проблема синхронизации действий этих потоков. </p>
<ul>
<li>Самым простым способом упорядочить работу потоков с общими данными являются <code>synchronized-блоки</code>.</li>
</ul>
</li>
<li><p><strong>synchronized-блоками</strong>  обозначаются критические секции — участки кода, которые в каждый момент времени могут выполняться только одним потоком. </p>
<ul>
<li>Синхронизация потоков всегда происходит с использованием какого-либо объекта. </li>
<li>Поток, входящий в synchronized-блок, захватывает монитор, связанный с объектом этого блока.</li>
<li>Пример создания synchronized-блока:<pre><code class="language-Java">private static final Object lock = new Object();
private static void transfer(int amount) {
  synchronized (lock) {
      account1 = account1 - amount;
      account2 = account2 + amount;
  }
}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Замки</strong> - являются более мощной версией synchronized-блока. Основные интерфейсы замков — <code>java.util.concurrent.locks.Lock</code> и <code>ReadWriteLock</code>, а наиболее полезные классы — <code>ReentrantLock</code> и <code>ReentrantReadWriteLock</code>.</p>
<ul>
<li>Пример создания замка:<pre><code class="language-Java">private static final Lock lock = new ReentrantLock();
lock.lock();
try {
  // критическая секция
} 
finally { 
  lock.unlock(); 
}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Пулы потоков</strong> - это набор потоков, которым можно передавать какие-либо задачи (например, Runnable) на выполнение. </p>
<ul>
<li>Создание потока — дорогая операция, и часто большинство задач выполняются недолго. Поэтому имеет смысл переиспользовать уже созданные потоки для  различных задач. </li>
<li>Пример создания пула потоков:<pre><code class="language-Java">Executor executor = Executors.newFixedThreadPool(4);
executor.execute(() -&gt; /* ... */ );
executor.execute(new Runnable() {
  @Override public void run() { /* ... */ } 
});
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Жизненный цикл потока</strong>. Поток проходит через несколько стадий своего жизненного цикла:</p>
<ul>
<li>New - новый поток начинает свой жизненный цикл с изначального состояния. Он остается в нем до тех пор, пока программа не запустит его.</li>
<li>Runnable - после того, как поток создался, его надо запустить, в связи с чем, он перейдет в данное состояние. Поток в таком состоянии уже выполняет свои функции.</li>
<li>Waiting - иногда переходы между потоками занимают некоторое время, во время которого поток находится в таком состоянии, до тех пор, пока другой поток не переведет его в состояние runnable.</li>
<li>Timed waiting - runnable поток может установить время ожидания для какого-то события, после чего перейдет в данное состояние. Он перейдет обратно в runnable только после того, как истечет указанное время, или если событие, которого он ждет, произойдет.</li>
<li>Terminated - runnable поток завершается после выполнения своих функций (или его завершают) и переходит в данное состояние.</li>
<li>Диаграмма жизненого цикла потока:
<img src="http://www.tutorialspoint.com/java/images/Thread_Life_Cycle.jpg" alt="Диаграмма жизненого цикла потока"></li>
</ul>
</li>
<li><p><strong>Приоритет</strong> - каждый поток имеет приоритет, который помогает операционной системе распознавать порядок в котором потоки будут работать: <code>MIN_PRIORITY</code>, <code>NORM_PRIORITY</code>, <code>MAX_PRIORITY</code>.</p>
</li>
</ol>
<hr>
<h3>8. Коллекции</h3><ol>
<li><p><strong>Массив</strong>. Массивы встроены в язык и довольно производительны; они часто служат основой других коллекций.</p>
</li>
<li><p><strong>Интерфейс <code>Collection&lt;T&gt;</code></strong> является базовым интерфейсом для линейных коллекций. Он предоставляет основные операции, общие для всех коллекций.</p>
<ul>
<li>Данный интерфейс предоставляет следующие методы: <code>add()</code>, <code>addAll()</code>, <code>clear()</code>, <code>contains()</code>, <code>containsAll()</code>, <code>equals()</code>, <code>hashCode()</code>, <code>isEmpty()</code>, <code>iterator()</code>, <code>remove()</code>, <code>removeAll()</code>, <code>size()</code>, <code>toArray()</code>.</li>
<li>Абстрактный класс <code>AbstractCollection</code> реализует большинство методов этого интерфейса.</li>
</ul>
</li>
<li><p><strong>Интерфейс <code>List&lt;T&gt;</code></strong> является одним из наиболее часто используемых интерфейсов коллекций, который обозначает упорядоченную коллекцию. Каждый элемент списка имеет целочисленный индекс; возможно добавление и удаление элементов по индексу. Дополнительно этот интерфейс предоставляет специальный итератор <code>ListIterator&lt;T&gt;</code>, который позволяет перемещаться по списку в обе стороны и вставлять новые элементы.</p>
<ul>
<li>Данный интерфейс предоставляет следующие методы: <code>get()</code>, <code>indexOf()</code>, <code>lastIndexOf()</code>, <code>listIterator()</code>, <code>set()</code>, <code>subList()</code>.</li>
<li>Абстрактный класс <code>AbstractList</code> наследуется от <code>AbstractCollection</code> и реализует большинство методов <code>List</code> интерфейса.</li>
<li>Абстрактный класс <code>AbstractSequentialList</code> наследуется от <code>AbstractList</code> и реализует большинство методов <code>List</code> интерфейса с упором на последовательный, чем на случайный доступ к элементам.</li>
</ul>
</li>
<li><p><strong>Реализация <code>ArrayList&lt;T&gt;</code></strong> используется чаще всего в интерфейсе <code>List</code>. По сути является реализацией списка на основе массива. Кроме того, <code>ArrayList</code> очень эффективно использует память, и операции, основанные на доступе по индексу (сортировка, перемешивание, бинарный поиск и т.д.), выполняются быстро.</p>
<ul>
<li>Данная реализация предоставляет следующие методы: <code>ensureCapacity()</code>, <code>removeRange()</code>, <code>trimToSize()</code>, <code>clone()</code>.</li>
</ul>
</li>
<li><p><strong>Реализация <code>LinkedList&lt;T&gt;</code></strong> используется гораздо реже. Является реализацией списка на основе двусвязного списка. <code>LinkedList</code> эффективнее при вставке/удалении элементов в начале или конце и при вставке/удалении в середине после итерации до нужного места. Также <code>LinkedList</code> потребляет значительно больше памяти, чем <code>ArrayList</code>.</p>
<ul>
<li>Данная реализация предоставляет следующие методы: <code>addFirst()</code>, <code>addLast()</code>, <code>clone()</code>, <code>getFirst()</code>, <code>getLast()</code>, <code>removeFirst()</code>, <code>removeLast()</code>.</li>
</ul>
</li>
<li><p><strong>Интерфейс <code>Set&lt;T&gt;</code></strong> предоставляет абстракцию математического множества, т.е. неупорядоченную коллекцию, не содержащую одинаковых элементов. Из-за неупорядоченности элементы множества нельзя получить по их индексу, поэтому для множеств не имеет смысла сортировка и перемешивание элементов. Однако при этом операции проверки на наличие элемента во множестве эффективнее, чем в списке.</p>
<ul>
<li>Данный интерфейс предоставляет следующие методы: <code>isEmpty()</code>.</li>
<li>Абстрактный класс <code>AbstractSet</code> наследуется от <code>AbstractCollection</code> и реализует большинство методов <code>Set</code> интерфейса.</li>
</ul>
</li>
<li><p><strong>Интерфейс <code>SortedSet&lt;T&gt;</code></strong> является расширением <code>Set&lt;T&gt;</code>. Он предполагает наличие отношения порядка на своих элементах. Из-за этого <code>SortedSet</code> предоставляет дополнительные операции.</p>
<ul>
<li>Данный интерфейс предоставляет следующие методы: <code>clone()</code>, <code>comparator()</code>, <code>first()</code>, <code>headSet()</code>, <code>last()</code>, <code>subSet()</code>, <code>tailSet()</code>.</li>
</ul>
</li>
<li><p><strong>Реализация <code>HashSet&lt;T&gt;</code></strong> — это наиболее часто используемая реализация множества, потому что основные задачи множества она выполняет наиболее эффективно. HashSet основан на <code>HashMap</code>. Поэтому, в частности, для использования <code>HashSet</code> необходима правильная реализация методов <code>equals()</code> и <code>hashCode()</code>.</p>
<ul>
<li>Данная реализация наследуется от <code>AbstractSet</code>.</li>
<li>Данная реализация предоставляет следующие методы: <code>clone()</code>.</li>
</ul>
</li>
<li><p><strong>Реализация <code>LinkedHashSet&lt;T&gt;</code></strong> объединяет множество на основе хеш-таблицы и связный список. Эффективность всех операций на нём та же, что и у <code>HashSet</code>, но порядок итерации по нему не псевдослучаен, а соответствует порядку добавления элементов в это множество. <code>LinkedHashSet</code> основан на <code>LinkedHashMap</code> и наследует <code>HashSet</code>, поэтому для него также справедливы условия на методы <code>equals()</code> и <code>hashCode()</code> у элементов.</p>
<ul>
<li>Данная реализация наследуется от <code>HashSet</code>.</li>
</ul>
</li>
<li><p><strong>Реализация <code>TreeSet&lt;T&gt;</code></strong> — это множество, основанное на <code>TreeMap</code>. Оно реализует интерфейс <code>SortedSet&lt;T&gt;</code>, и в нём могут храниться только элементы, на которых задано отношение порядка. Класс <code>TreeSet</code> основан на <code>TreeMap</code>, и поэтому все операции над элементами имеют логарифмическую сложность. Это хуже, чем у <code>HashSet</code>, поэтому TreeSet используется только тогда, когда необходимо так или иначе сортировать элементы множества.</p>
<ul>
<li>Данная реализация наследуется от <code>AbstractSet</code>.</li>
<li>Данная реализация предоставляет следующие методы: <code>clone()</code>, <code>comparator()</code>, <code>first()</code>, <code>last()</code>, <code>headSet()</code>, <code>subSet()</code>, <code>tailSet()</code>.</li>
</ul>
</li>
<li><p><strong>Интерфейс <code>Queue&lt;T&gt;</code></strong> представляет собой контейнер, в который можно добавлять элементы и доставать их оттуда. Релизации <code>Queue&lt;T&gt;</code> могут ограничивать максимальное количество элементов в коллекции. Поэтому <code>Queue&lt;T&gt;</code> предоставляет два набора методов для указанных операций. Первый набор в граничных ситуациях выбрасывает исключение, а второй — возвращает специальное значение (null или boolean).</p>
<ul>
<li>Абстрактный класс <code>AbstractQueue</code> наследуется от <code>AbstractCollection</code> и реализует большинство методов <code>Queue</code> интерфейса.</li>
<li>Данный интерфейс предоставляет следующие методы: <code>offer()</code>, <code>peek()</code>, <code>poll()</code>.</li>
</ul>
</li>
<li><p><strong>Интерфейс <code>Deque&lt;T&gt;</code></strong> обозначает дек, структуру данных, являющуюся одновременно стеком и очередью. В дек можно добавлять и удалять элементы с двух сторон.</p>
<ul>
<li>Данный интерфейс предоставляет следующие методы: <code>offer()</code>, <code>peek()</code>, <code>poll()</code>, <code>addFirst()</code>, <code>addLast()</code>, <code>descendingIterator()</code>, <code>element()</code>, <code>getFirst()</code>, <code>getLast()</code>, <code>offerFirst()</code>, <code>offerLast()</code>, <code>peekFirst()</code>, <code>peekLast()</code>, <code>pollFirst()</code>, <code>pollLast()</code>, <code>pop()</code>, <code>push()</code>, <code>removeFirst()</code>, <code>removeFirstOccurrence()</code>, <code>removeLast()</code>, <code>removeLastOccurrence()</code>, <code>size()</code>.</li>
</ul>
</li>
<li><p><strong>Реализация <code>ArrayDeque&lt;T&gt;</code></strong> с помощью массива - наиболее удобная и эффективная.</p>
<ul>
<li>Данная реализация наследуется от <code>AbstractCollection</code> и реализует интерфейс <code>Deque</code>.</li>
<li>Данный интерфейс предоставляет следующие методы: <code>isEmpty()</code>, <code>clone()</code>, <code>toArray()</code>.</li>
</ul>
</li>
<li><p><strong><code>java.util.Arrays</code></strong> предоставляет статические методы для манипуляций с массивами, такие как: <code>binarySearch()</code>, <code>equals()</code>, <code>fill()</code>, <code>sort()</code>.</p>
</li>
<li><p><strong><code>java.util.Collections</code></strong> предоставляет статические методы для манипуляций с массивами, такие как: <code>binarySearch()</code>, <code>fill()</code>, <code>sort()</code>, <code>copy()</code>, <code>enumeration()</code>, <code>indexOfSubList()</code>, <code>lastIndexOfSubList()</code>, <code>list()</code>, <code>max()</code>, <code>min()</code>, <code>nCopies()</code>, <code>replaceAll()</code>, <code>reverse()</code>, <code>reverseOrder()</code>, <code>rotate()</code>, <code>shuffle()</code>, <code>singleton()</code>, <code>singletonList()</code>, <code>singletonMap()</code>, <code>swap()</code>, <code>synchronizedCollection()</code>, <code>synchronizedList()</code>, <code>synchronizedMap()</code>, <code>synchronizedSet()</code>, <code>synchronizedSortedMap()</code>, <code>synchronizedSortedSet()</code>, <code>unmodifiableCollection()</code>, <code>unmodifiableList()</code>, <code>unmodifiableMap()</code>, <code>unmodifiableSet()</code>, <code>unmodifiableSortedMap()</code>, <code>unmodifiableSortedSet()</code>.</p>
</li>
<li><p>Иерархия коллекций<br><img src="https://i.gyazo.com/c728629e97972ba7d715d23c2f3e7b51.png" alt="Иерархия коллекций"></p>
</li>
</ol>
<hr>
<h3>9. Мапы</h3><ol>
<li><p><strong>Интерфейс <code>Map&lt;K, V&gt;</code></strong> представляет абстракцию ассоциативного массива (словаря, отображения). Он хранит пары (ключ, значчение) и поддерживает три основные операции: <code>put</code>, <code>get</code>, <code>remove</code>. При этом предполагается, что ключи уникальны. Если операция <code>put</code> вызывается с ключом, который уже есть в ассоциативном массиве, соответствующее значение будет заменено.</p>
<ul>
<li>Абстрактный класс <code>AbstractMap</code> реализует большинство методов <code>Map</code> интерфейса.</li>
<li>Данный интерфейс предоставляет следующие методы: <code>clear()</code>, <code>containsKey()</code>, <code>containsValue()</code>, <code>entrySet()</code>, <code>equals()</code>, <code>get()</code>, <code>hashCode()</code>, <code>isEmpty()</code>, <code>keySet()</code>, <code>put()</code>, <code>putAll()</code>, <code>remove()</code>, <code>size()</code>, <code>values()</code>.</li>
</ul>
</li>
<li><p><strong>Интерфейс <code>SortedMap&lt;K, V&gt;</code></strong> обозначает словарь, в котором на ключах задано отношение порядка. Аналогично <code>SortedSet&lt;T&gt;</code>, <code>SortedMap&lt;K, V&gt;</code> предоставляет дополнительные операции. Предполагается, что эти операции словарь способен выполнять эффективно.</p>
<ul>
<li>Данный интерфейс наследуется от <code>Map</code> интерфейса.</li>
<li>Данный интерфейс предоставляет следующие методы: <code>comparator()</code>, <code>firstKey()</code>, <code>headMap()</code>, <code>lastKey()</code>, <code>subMap()</code>, <code>tailMap()</code>.</li>
</ul>
</li>
<li><p><strong>Реализация <code>HashMap&lt;K, V&gt;</code></strong> - словарь на основе хеш-таблицы. Из-за этого все операции над <code>HashMap</code> очень эффективны. HashMap реализован как хеш-таблица на основе цепочек. Внутри он содержит массив «корзин», каждая из которых является односвязным списком. Поэтому элементы словаря должны корректно реализовывать методы <code>equals()</code> и <code>hashCode()</code>. Для идеальной хеш-функции эффективность операций константная.</p>
<ul>
<li>Данная реализация наследуется от <code>AbstractMap</code> и реализует <code>Map</code> интерфейс.</li>
<li>Данная реализация предоставляет следующие методы: <code>clone()</code>.</li>
</ul>
</li>
<li><p><strong>Реализация <code>LinkedHashMap&lt;K, V&gt;</code></strong> объединяет хеш-таблицу и связный список. Используется, когда необходимо сохранять порядок добавления элементов в словарь. Помимо структуры хеш-таблицы, <code>LinkedHashMap</code> добавляет новые записи в связный список. С помощью этого можно восстановить порядок добавления элементов. Эффективность операций у <code>LinkedHashMap</code> та же, что и у обычного <code>HashMap</code>, но из-за дополнительной структуры на элементах потребление памяти выше.</p>
<ul>
<li>Данная реализация наследуется от <code>HashMap</code> и реализует <code>Map</code> интерфейс.</li>
<li>Данная реализация предоставляет следующие методы: <code>removeEldestEntry()</code>.</li>
</ul>
</li>
<li><p><strong>Реализация <code>TreeMap&lt;K, V&gt;</code></strong> — это реализация словаря на основе красно-чёрного бинарного дерева поиска (дерево образуют ключи). Эта структура требует отношения порядка на элементах, поэтому <code>TreeMap</code> реализует интерфейс <code>SortedMap</code>. Поскольку внутри <code>TreeMap</code> используется бинарное дерево, то все операции имеют логарифмическую эффективность.</p>
<ul>
<li>Данная реализация наследуется от <code>AbstractMap</code> и реализует <code>SortedMap</code> интерфейс.</li>
<li>Данная реализация предоставляет следующие методы: <code>clone()</code>.</li>
</ul>
</li>
<li><p>Иерархия мапов<br> <img src="https://i.gyazo.com/edfb3a3797946a21747880fcac1507ba.png" alt="Иерархия мапов"></p>
</li>
</ol>
<hr></div></div></section><section class="vibrant centered"><div><h4>© Copyright 2016 <a href="https://github.com/Praytic">Chernogorov Vladislav</a></h4></div></section></body><script src="//ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/highlight.min.js"></script><script src="/js/layout.js"></script><script type="text/javascript">hljs.initHighlightingOnLoad();</script></html>