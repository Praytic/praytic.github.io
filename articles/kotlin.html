<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><title>Java Dev Lib</title><meta name="description" content="Солянка из теорий различных технологий, так или иначе связанных с разработкой или с Java. Большинство теории переведено с англоязычных ресурсов."/><meta name="author" content="Chernogorov Vladislav"/><meta name="handheldfriendly" content="true"/><meta name="mobileoptimized" content="320"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="cleartype" content="on"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><link rel="stylesheet" href="/css/style.css"/><link rel="stylesheet" href="/css/github-markdown.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/styles/default.min.css"/><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject'] = r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-75180616-1', 'auto');
ga('send', 'pageview');</script></head><body class="wrapper"><header><div class="container"><h2 class="lone-header">Java Dev Lib</h2></div></header><section><div class="container"><ul class="docs-nav"><li><strong><a href="/">Оглавление</a></strong></li><li><a href="/articles/web-service">Web Service</a></li><li><a href="/articles/java-se">Java SE</a></li><li><a href="/articles/java-ee">Java EE</a></li><li><a href="/articles/spring">Spring</a></li><li><a href="/articles/git">Git</a></li><li><a href="/articles/sql">SQL</a></li><li><a href="/articles/design-patterns">Design Patterns</a></li><li><a href="/articles/junit">JUnit</a></li><li><a href="/articles/design-patterns">Apache POI</a></li><hr/><li><a href="/articles/example">Example</a></li></ul><div class="docs-content markdown-body"><h1>Kotlin</h1><h3>1. Идиомы</h3><ol>
<li><p><strong>DTO (Data Transfer Object)</strong> - обычный объект, который используется для пересылки или хранения данных. </p>
<ul>
<li>Пример создания класса <code>Customer</code> c геттерами и сеттерами для всех полей. Модификтор <code>data</code> предоставляет методы <code>equals()</code>, <code>hashCode()</code>, <code>toString()</code>, <code>copy()</code>, а также возможность деструктурирования.<pre><code class="language-Kotlin">data class Customer(val name: String, val email: String)
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Параметры по-умолчанию</strong> - котлин поддерживает параметры по-умолчанию.</p>
<ul>
<li>Пример:<pre><code class="language-Kotlin">fun foo(a: Int = 0, b: String = &quot;&quot;) { ... }
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Фильтрация</strong> - у коллекций в котлине имеется метод filter, который в сочитании с лямбда-выражениями позволяет удобно отсеивать нужные значения коллекции.</p>
<ul>
<li>Пример:<pre><code class="language-Kotlin">val positives = list.filter { x -&gt; x &gt; 0 }
val positives = list.filter { it &gt; 0 }
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Подстановка</strong> - в котлине есть возможность подстановки значений переменных в строку используя имя переменной.</p>
<ul>
<li>Пример:<pre><code class="language-Kotlin">val name = &quot;NAME&quot;
println(&quot;Name $name&quot;)
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Проверка типа</strong> - совмещая операторы <code>when</code> и <code>is</code> можно добиться удобной проверки на тип объекта.</p>
<ul>
<li>Пример:<pre><code class="language-Kotlin">when (x) {
 is Foo -&gt; ...
 is Bar -&gt; ...
 else   -&gt; ...
}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Диапазоны</strong> - в котлине имееется оператор <code>..</code> для обозначения диапазонов.</p>
<ul>
<li>Пример:<pre><code class="language-Kotlin">for (i in 1..100) { ... }  // closed range: includes 100
for (i in 1 until 100) { ... } // half-open range: does not include 100
for (x in 2..10 step 2) { ... }
for (x in 10 downTo 1) { ... }
if (x in 1..10) { ... }
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Read-only коллекции</strong></p>
<pre><code class="language-Kotlin">for (i in 1..100) { ... }  // closed range: includes 100
for (i in 1 until 100) { ... } // half-open range: does not include 100
for (x in 2..10 step 2) { ... }
for (x in 10 downTo 1) { ... }
if (x in 1..10) { ... }
</code></pre>
</li>
<li><p><strong>Доступ по ключу</strong></p>
<pre><code class="language-Kotlin">map[&quot;key&quot;] = value
</code></pre>
</li>
<li><p><strong>Singleton</strong></p>
<pre><code class="language-Kotlin">object Resource {
   val name = &quot;Name&quot;
}
</code></pre>
</li>
<li><p><strong>Выражения с возвратом значения</strong></p>
<pre><code class="language-Kotlin">result = when (color) {
   &quot;Red&quot; -&gt; 0
   &quot;Green&quot; -&gt; 1
   &quot;Blue&quot; -&gt; 2
   else -&gt; throw IllegalArgumentException(&quot;Invalid color param value&quot;)
}
</code></pre>
<pre><code class="language-Kotlin">result = try {
   count()
} catch (e: ArithmeticException) {
   throw IllegalStateException(e)
}
</code></pre>
<pre><code class="language-Kotlin">result = if (param == 1) {
   &quot;one&quot;
} else if (param == 2) {
   &quot;two&quot;
} else {
   &quot;three&quot;
}
</code></pre>
</li>
</ol>
<hr>
<h3>1. Базовые конструкции</h3><ol>
<li><p><strong>Типы данных</strong></p>
<ul>
<li>Синтаксис типа:<pre><code class="language-Kotlin">annotations typeDescriptor
</code></pre>
<ul>
<li><code>typeDescriptor</code> может быть функцией, пользовательским типом, nullable типом или dynamic.</li>
<li><code>annotations</code> состоит из одной или нескольких аннотаций.</li>
</ul>
</li>
<li><strong><code>Number</code></strong> - данный тип схож с джавовским, но не совсем. В котлине он представляет следующие типы (не наследуются): <code>Double</code>, <code>Float</code>, <code>Long</code>, <code>Int</code>, <code>Short</code>, <code>Byte</code>.<ul>
<li>Десятичные числа: <code>123</code>. Long числа: <code>123L</code></li>
<li>Шестнадцетиричные числа: <code>0x0F</code></li>
<li>Двоичные числа: <code>0b00001011</code></li>
<li>Числа с плавающей точкой: <code>123.5</code>, <code>123.5e10</code>. Float числа: <code>123.5f</code></li>
<li>В котлине не поддерживается неявное преобразование малых чисел в больше (Byte в Int, например).</li>
</ul>
</li>
<li><strong><code>Char</code></strong> - в котлине символы не могут воспринматься как числа, в отличии от джавы.<ul>
<li>Экранируемые символы: <code>\t</code>, <code>\b</code>, <code>\n</code>, <code>\r</code>, <code>\&#39;</code>, <code>\&quot;</code>, <code>\\</code>, <code>\$</code> или символ юникода <code>&#39;\uFF00&#39;</code></li>
</ul>
</li>
<li><strong><code>Boolean</code></strong> - булев тип, принимающий <code>true</code> или <code>false</code>.</li>
<li><strong><code>Array</code></strong> - массивы в котлине представлены этим классом, который имеет геттер и сеттер в виде квадратных скобок.<ul>
<li>В отличии от массивов в джава, массивы в котлине инварианты. Это значит, что нельзя присвоить значение типа <code>Array&lt;String&gt;</code> переменной типа <code>Array&lt;Any&gt;</code>. Для этого нужно использовать явное преобразование.</li>
</ul>
</li>
<li><strong><code>String</code></strong> - строки как и в джава - неизменяемы, к элементам строки (символам) можно образаться с помощью геттера в виде квадратных скобок.<ul>
<li>Тройные кавычки обозначают, что текст внутри них останется таким, каким он выглядит в редакторе (за исключением отступов, их можно указать с помощью знака <code>|</code>).</li>
<li>Строковые темплейты можно делать с помощью <code>$</code>: <pre><code class="language-Kotlin">val s = &quot;abc&quot;
val str = &quot;$s.length is ${s.length}&quot;.
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Операции</strong> - операции в котлине разделяются на следующие группы:</p>
<ul>
<li>Арифметические операции: <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>%</code>, <code>++</code>, <code>--</code>.</li>
<li>Сравнительные операции: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&lt;</code>.</li>
<li>Побитовые операции: <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>.</li>
<li>Логические операции: <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>.</li>
<li>Операции присваивания: <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>^=</code>, <code>|=</code>.</li>
<li>Прочие операции: <code>() ? () : ()</code>, <code>instanceof</code></li>
</ul>
</li>
</ol>
<h3>1. Элементы</h3><p>Обозначение нотаций, которые будут использоваться для определения синтаксиса элементов:</p>
<ul>
<li>Имена конечных элементов начинаются с большой буквы. (SimpleName)</li>
<li>Имена неконечных элементов начинаются с маленькой буквы. (kotlinFile)</li>
<li>Оператор <code>|</code> обозначает &quot;или&quot;.</li>
<li>Оператор <code>*</code> обозначает &quot;может содержать несколько&quot;.</li>
<li>Оператор <code>+</code> обозначает &quot;сожержит несколько&quot;.</li>
<li>Оператор <code>?</code> обозначает &quot;может содержать один&quot;.</li>
<li>Оператор <code>X{Y}</code> обозначает непустую последовательность из X-ов, разделенных символом Y.</li>
<li>Оператор <code>++</code> обозначает, что между операндами недопустимы пробелы или комментарии.  </li>
<li>Операнд <code>SEMI</code> обозначает новую строку или точку с запятой.  </li>
</ul>
<ol>
<li><p><strong>kotlinFile</strong> - файл состоит из начального поля и может содержать несколько объектов высокого уровня.</p>
<ul>
<li>Синтаксис:<pre><code class="language-Kotlin">preamble toplevelObject*
</code></pre>
</li>
</ul>
</li>
<li><p><strong>script</strong> - скрипт состоит из начального поля и может содержать несколько выражений.</p>
<ul>
<li>Синтаксис:<pre><code class="language-Kotlin">preamble expression*
</code></pre>
</li>
</ul>
</li>
<li><p><strong>preamble</strong> - начальное поле может содержать файловые аннотации, заголовок пакета и несколько импортов. </p>
<ul>
<li>Синтаксис:<pre><code class="language-Kotlin">fileAnnotations? packageHeader? import*
</code></pre>
</li>
</ul>
</li>
<li><p><strong>fileAnnotations</strong> - файловые аннотации могут содержать несколько файловых аннотаций.</p>
<ul>
<li>Синтаксис:<pre><code class="language-Kotlin">fileAnnotation*
</code></pre>
</li>
</ul>
</li>
<li><p><strong>fileAnnotation</strong> - файловая аннотация содержит одну или более аннотацию.</p>
<ul>
<li>Синтаксис:<pre><code class="language-Kotlin">&quot;@&quot; &quot;file&quot; &quot;:&quot; (&quot;[&quot; annotationEntry+ &quot;]&quot; | annotationEntry)
</code></pre>
</li>
</ul>
</li>
<li><p><strong>packageHeader</strong> - заголовок пакета содержит модификаторы и последовательность имен.</p>
<ul>
<li>Синтаксис:<pre><code class="language-Kotlin">modifiers &quot;package&quot; SimpleName{&quot;.&quot;} SEMI?
</code></pre>
</li>
</ul>
</li>
<li><p><strong>import</strong> - импорт состоит из последовательности имен и может содержать в конце &#39;*&#39; или еще одно имя.</p>
<ul>
<li>Синтаксис:<pre><code class="language-Kotlin">&quot;import&quot; SimpleName{&quot;.&quot;} (&quot;.&quot; &quot;*&quot; | &quot;as&quot; SimpleName)? SEMI?
</code></pre>
</li>
</ul>
</li>
<li><p><strong>toplevelObject</strong> - высокоуровневый объект - это пакет, класс, объект, функция или проперти.</p>
<ul>
<li>Синтаксис:<pre><code class="language-Kotlin">package | class | object | function | property
</code></pre>
</li>
</ul>
</li>
<li><p><strong>package</strong> - пакет состоит из последовательности имен, может содержать импорты и высокоуровневые объекты.</p>
<ul>
<li>Синтаксис:<pre><code class="language-Kotlin">&quot;package&quot; SimpleName{&quot;.&quot;} &quot;{&quot;
import*
toplevelObject*
&quot;}&quot;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>class</strong> - класс состоит из модификаторов, имени, ограничений, тела класса или перечисления, а также может содержать параметры типов, основной контруктор, аннотации с последовательностью делегатов и пустое тело класса.</p>
<ul>
<li>Синтаксис:<pre><code class="language-Kotlin">modifiers (&quot;class&quot; | &quot;interface&quot;) SimpleName
 typeParameters?
 primaryConstructor?
 (&quot;:&quot; annotations delegationSpecifier{&quot;,&quot;})?
 typeConstraints
 (classBody? | enumClassBody)
</code></pre>
</li>
</ul>
</li>
<li><p><strong>primaryConstructor</strong> - основной конструктор содержит последовательность параметров функции и может содержать модификаторы.</p>
<ul>
<li>Синтаксис:<pre><code class="language-Kotlin">(modifiers &quot;constructor&quot;)? (&quot;(&quot; functionParameter{&quot;,&quot;} &quot;)&quot;)
</code></pre>
</li>
</ul>
</li>
<li><p><strong>classBody</strong> - тело класса содержит члены класса.</p>
<ul>
<li>Синтаксис:<pre><code class="language-Kotlin">(&quot;{&quot; members &quot;}&quot;)?
</code></pre>
</li>
</ul>
</li>
<li><p><strong>members</strong> - члены класса могут содержать члены определения.</p>
<ul>
<li>Синтаксис:<pre><code class="language-Kotlin">memberDeclaration*
</code></pre>
</li>
</ul>
</li>
<li><p><strong>delegationSpecifier</strong> - делегат состоит из вызова конструктора, пользовательского типа или явного делегирования.</p>
<ul>
<li>Синтаксис:<pre><code class="language-Kotlin">constructorInvocation | userType | explicitDelegation
</code></pre>
</li>
</ul>
</li>
<li><p><strong>explicitDelegation</strong> - </p>
<ul>
<li>Синтаксис:<pre><code class="language-Kotlin">preamble toplevelObject*
</code></pre>
</li>
</ul>
</li>
<li><p><strong>typeParameters</strong> - </p>
<ul>
<li>Синтаксис:<pre><code class="language-Kotlin">preamble toplevelObject*
</code></pre>
</li>
</ul>
</li>
<li><p><strong>typeParameter</strong> - </p>
<ul>
<li>Синтаксис:<pre><code class="language-Kotlin">preamble toplevelObject*
</code></pre>
</li>
</ul>
</li>
<li><p><strong>typeConstraints</strong> - </p>
<ul>
<li>Синтаксис:<pre><code class="language-Kotlin">preamble toplevelObject*
</code></pre>
</li>
</ul>
</li>
<li><p><strong>typeConstraint</strong> - </p>
<ul>
<li>Синтаксис:<pre><code class="language-Kotlin">preamble toplevelObject*
</code></pre>
</li>
</ul>
</li>
<li><p><strong>kotlinFile</strong> - </p>
<ul>
<li>Синтаксис:<pre><code class="language-Kotlin">preamble toplevelObject*
</code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<h3>3. ООП</h3><ol>
<li><p><strong>ООП (Объектно Ориентированное Программирование)</strong> - методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы в свою очередь образуют иерархию наследования.</p>
</li>
<li><p><strong>Инкапсуляция</strong> - сокрытие реализации.</p>
<ul>
<li>Реализуется с помощью модификаторов видимости: <code>default</code>, <code>public</code>, <code>protected,</code> <code>private</code>.</li>
</ul>
</li>
<li><p><strong>Полиморфизм</strong> - парадигма ООП. Существует несколько его разновидностей:</p>
<ul>
<li><strong>Ad-hoc (ситуативный) полиморфизм</strong> — функция по-разному работает с данными разных типов из заранее фиксированного набора. Реализуется с помощью перегрузки методов.</li>
<li><strong>Параметрический полиморфизм</strong> — функция работает одинаково с данными произвольных типов. Реализуется с помощью дженериков и параметризованных классов. </li>
<li><strong>Полиморфизм подтипов</strong> — функция работает одинако-во с данными типов, являющихся подтипами одного общего супер-типа, редоставляющего общий интерфейс. Реализуется с помощью наследования и иерархии классов.</li>
<li><strong>Динамический полиморфизм</strong> — то, какой метод (из суперкласса или из подкласса) будет вызван, зависит от настоящего типа объекта, т.е. от того, объект какого класса на самом деле содержится в переменной. Реализуется с помощью позднего связыванания.</li>
</ul>
</li>
<li><p><strong>Наследование</strong> - возможность создавать потомков и переопределять часть функциональности класса.</p>
<ul>
<li>Реализуется с помощью ключевого слова extends.</li>
<li>Java не поддерживает множественное наследование классов.</li>
</ul>
</li>
<li><p><strong>Абстракция</strong> - это выделение общих характеристик объекта, отличая от всех других объектов.</p>
<ul>
<li>Реализуется с помощью абстрактных классов и интерфейсов.</li>
</ul>
</li>
<li><p><strong>Класс</strong> — это описание структуры и поведения объектов.</p>
</li>
<li><p><strong>Объекты</strong> — это участки памяти виртуальной машины, содержащие своё состояние в виде полей.</p>
</li>
</ol>
<hr>
<h3>4. Базовые конструкции</h3><ol>
<li><p><strong>Типы данных</strong> - в Java существует два типа данных: примитивные и ссылочные:</p>
<ul>
<li>Примитивные типы: <code>byte</code>, <code>short</code>, <code>int</code>, <code>float</code>, <code>double</code>, <code>long</code>, <code>boolean</code>, <code>char</code>.</li>
<li>Ссылочные типы: обертки примитивных типов, объекты классов, массивы.</li>
</ul>
</li>
<li><p><strong>Операции</strong> - операции в Java разделяются на следующие группы:</p>
<ul>
<li>Арифметические операции: <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>%</code>, <code>++</code>, <code>--</code>.</li>
<li>Сравнительные операции: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&lt;</code>.</li>
<li>Побитовые операции: <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>.</li>
<li>Логические операции: <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>.</li>
<li>Операции присваивания: <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>^=</code>, <code>|=</code>.</li>
<li>Прочие операции: <code>() ? () : ()</code>, <code>instanceof</code></li>
</ul>
</li>
<li><p><strong>Строка</strong> - последовательность символов, в Java строки являются объектами.</p>
<ul>
<li>Строки реализованы с помощью класса <code>String</code>.</li>
<li>Строки в Java неизменяемы (immutable) в целях безопасности, поэтому строки могут кэшировать свой хэшкод, что делает ее очень быстрой как ключ для <code>HashMap</code>. При том, строки могут свободно использоваться различными потоками, не боясь, что кто-то их изменит, таким образом отпадает необходимость в синхронизации.</li>
<li>Если строку нужно изменять, то следует использовать <code>StringBuilder</code> или <code>StringBuffer</code>.</li>
<li><code>StringTokenizer</code> - позволяет разбивать текст на лексемы, отделяемые разделителями. Парсит данные. Быстрый. Не поддерживает регулярные выражения. Устаревший.</li>
<li><code>String.split</code> - позволяет разбивать текст на лексемы, отделяемые разделителями. Поддерживает регулярные выражения. Возвращаемым значением является массив строк. Работает медленее, чем <code>StringTokenizer</code>.</li>
<li><code>Formatter</code> - обеспечивает преобразование формата, позволяющее выводить числа, строки, время и даты в любом необходимом разработчику виде.</li>
<li><code>Pattern</code> - применяется для определения регулярных выражений (шаблонов), для которых ищется соответствие в строке, файле или другом объекте, представляющем последовательность символов.</li>
<li><code>Matcher</code> - если необходимо найти соответствия внутри строки, необходимо использовать этот класс.</li>
</ul>
</li>
<li><p><strong>Массив</strong> - фиксированная структура данных.</p>
<ul>
<li>Массивы в Java объявляются следующим образом: <pre><code class="language-Java">dataType[] arrayRefVar = new dataType[arraySize];
dataType[] arrayRefVar = {value0, value1, ..., valueK};
</code></pre>
</li>
<li>Также существует Arrays класс, который предоставляет статические методы для манипуляций с массивами, такие как: <pre><code class="language-Java">public static int binarySearch(Object[] a, Object key)
public static boolean equals(long[] a, long[] a2)
public static void fill(int[] a, int val)
public static void sort(Object[] a)
</code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<h3>5. Модификаторы</h3><ol>
<li><p><strong><code>private</code></strong> (переменные / конструкторы / методы / внутренние классы) - члены класса доступны только внутри класса.</p>
</li>
<li><p><strong><code>package-private</code></strong> или <strong><code>default</code></strong> (переменные / конструкторы / методы / классы) - члены класса видны внутри пакета.</p>
</li>
<li><p><strong><code>protected</code></strong> (переменные / методы / конструкторы / внутренние классы) - члены класса доступны внутри пакета и в классах-наследника.</p>
</li>
<li><p><strong><code>public</code></strong> (все) - члены класса доступны всем.</p>
</li>
<li><p><strong><code>static</code></strong> (логические блоки / переменные / методы / классы) - статические блоки выполняются во время загрузки класса. К статическим методам и переменным можно обращаться через имя класса. </p>
</li>
<li><p><strong><code>abstract</code></strong> (методы / классы) - абстрактные классы должны наследоваться, а абстрактные методы - реализовываться.</p>
</li>
<li><p><strong><code>final</code></strong> (переменные / методы / классы) - переменные, которым было присвоино значение, не могут быть переприсвоены. Методы не могут быть перегруженны. Классы не могут быть наследованы.</p>
</li>
<li><p><strong><code>synchronized</code></strong> (методы / части метода) - метод может одновременно использоваться только одним потоком.</p>
</li>
<li><p><strong><code>transient</code></strong> (переменные) - переменная не сериализуется. Локальные переменные не могут быть объявлены как transient. </p>
</li>
<li><p><strong><code>volatile</code></strong> (переменные) - значение переменной, объявленной как volatile, измененное одним потоком, асинхронно меняется и для других потоков. </p>
</li>
<li><p><strong><code>native</code></strong> (методы) - обозначает, что метод написан на другом языке программирования.</p>
</li>
<li><p><strong><code>strictfp</code></strong> (методы / классы) - обеспечивает выполнение операций над числами типа float и double (с плавающей запятой) по стандарту IEEE 754.</p>
</li>
</ol>
<hr>
<h3>6. Дженерики</h3><ol>
<li><p><strong>Дженерики</strong> — реализация обобщенного программирования, включающая в себя поддержку обобщенных классов и обобщенных методов. </p>
</li>
<li><p><strong>Обобщенные классы</strong> - обобщенные (параметризованные) классы могут использоваться для следующих целей:</p>
<ul>
<li>Коллекции и контейнеры: <code>List&lt;Integer&gt;</code>, <code>Set&lt;Long&gt;</code>, <code>Map&lt;String, Runnable&gt;</code>, <code>Future&lt;HttpResponse&gt;</code>, <code>Optional&lt;Model&gt;</code>.</li>
<li>Компараторы<pre><code class="language-Java">public interface Comparator&lt;T&gt; {
  int compare(T left, T right);
}
</code></pre>
</li>
<li>Объекты-команды<pre><code class="language-Java">public interface Function&lt;F, T&gt; {
  T apply(F arg);
}
public interface Callable&lt;T&gt; {
  T call() throws Exception;
}
</code></pre>
</li>
<li>Провайдеры<pre><code class="language-Java">public interface Provider&lt;T&gt; {
  T get();
}
public interface ThrowingProvider&lt;T, E extends Throwable&gt; {
  T get() throws E;
}
</code></pre>
</li>
<li>Обобщенные DAO<pre><code class="language-Java">public abstract class GenericDAO&lt;T, ID&gt; {
  protected GenericDAO(Class&lt;T&gt; clazz) { ... }
  public T findById(ID id) { ... }
}
</code></pre>
</li>
<li>Конверторы<pre><code class="language-Java">public interface StringConverter&lt;T&gt; {
  T fromString(String s);
  String toString(T obj);
}
</code></pre>
</li>
<li>Кортежи<pre><code class="language-Java">public class TwoTuple&lt;A,B&gt; { 
  public final A first; 
  public final B second; 
  public TwoTuple(A a, B b) { 
      first = a; second = b; 
  }
}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Обобщенные методы</strong> - обобщенные (параметризованные) методы могут использоваться для следующих целей:</p>
<ul>
<li>Обобщенные фабричные методы:<pre><code class="language-Java">public static &lt;T extends Enum&lt;T&gt;&gt; EnumSet&lt;T&gt; allOf(Class&lt;T&gt; clazz);
public static &lt;T&gt; ImmutableList&lt;T&gt; of(T pɴ, T pɵ, T... other);
public &lt;T&gt; T getInstance(Key&lt;T&gt; key);
</code></pre>
</li>
<li>Методы-преобразователи<pre><code class="language-Java">public static &lt;T&gt; Iterable&lt;T&gt; skip(Iterable&lt;T&gt; iterable, int n);
public static &lt;F, T&gt; Iterable&lt;T&gt; transform(Iterable&lt;F&gt; iterable, Function&lt;F, T&gt; function);
</code></pre>
</li>
<li>Обобщенные утилитные методы<pre><code class="language-Java">public static &lt;T extends Comparable&lt;T&gt;&gt; T max(Iterable&lt;T&gt; xs);
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Wildcards</strong> - wildcards существуют трех типов:</p>
<ul>
<li>Wildcards with upper bound:<pre><code class="language-Java">public static double sumOfList(List&lt;? extends Number&gt; list);
</code></pre>
</li>
<li>Unbounded wildcard<pre><code class="language-Java">void printCollection(Collection&lt;?&gt; c);
</code></pre>
</li>
<li>Wildcards with lower bound<pre><code class="language-Java">public static void addNumbers(List&lt;? super Integer&gt; list);
</code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<h3>7. Многопоточность</h3><ol>
<li><p><strong>Многопоточность</strong> - это когда множество процессов делят общие вычислительные ресурсы, такие как CPU, между собой.</p>
<ul>
<li>Многопотчная программа содержит 2 или более частей, который могут работать одновременно, и каждая часть может выполнять свое действие, тем самым создавая оптимальные условия для использования доступных ресурсов.</li>
<li>Многопоточность расширяет идею многозадачности в приложениях, где можно разделить определенные операции в индивидуальные потоки.</li>
<li>Операционная система разделяет вычислительное время не только между различными программами, но и между потоками этих приложений.</li>
</ul>
</li>
<li><p><strong>Поток</strong> в Java представлен классом <code>java.lang.Thread</code>, объекты которого являются потоками, работающими внутри текущей JVM. </p>
<ul>
<li>Каждый поток может работать параллельно.</li>
<li>Начиная с версии 1.5 в состав стандартной библиотеки Java входит пакет <code>java.util.concurrent</code>, в котором содержится большое количество различных классов, помогающих при разработке многопоточных программ.</li>
</ul>
</li>
<li><p><strong>Создание потока</strong>. Для того, чтобы выполнить какую-либо задачу в отдельном потоке, можно создать новый поток с помощью конструктора класса <code>Thread</code>, передать ему <code>Runnable</code> и запустить его.</p>
<ul>
<li>Пример создания потока:<pre><code class="language-Java">new Thread(new Runnable() {
  @Override public void run() { /* ... */ }
}).start();
new Thread(() -&gt; { /* ... */ }).start();
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Создание сервисного потока</strong>. Выполнение Java-машины завершается, когда завершатся все потоки, не являющиеся сервисными, т.е. те, у которых не установлен флаг daemon.</p>
<ul>
<li>Пример создания сервисного потока:<pre><code class="language-Java">Thread t = new Thread(() -&gt; { ... });
t.setDaemon(true);
t.start();
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Критические секции</strong>. При работе потоков с общей изменяемой памятью неизбежно возникает проблема синхронизации действий этих потоков. </p>
<ul>
<li>Самым простым способом упорядочить работу потоков с общими данными являются <code>synchronized-блоки</code>.</li>
</ul>
</li>
<li><p><strong>synchronized-блоками</strong>  обозначаются критические секции — участки кода, которые в каждый момент времени могут выполняться только одним потоком. </p>
<ul>
<li>Синхронизация потоков всегда происходит с использованием какого-либо объекта. </li>
<li>Поток, входящий в synchronized-блок, захватывает монитор, связанный с объектом этого блока.</li>
<li>Пример создания synchronized-блока:<pre><code class="language-Java">private static final Object lock = new Object();
private static void transfer(int amount) {
  synchronized (lock) {
      account1 = account1 - amount;
      account2 = account2 + amount;
  }
}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Замки</strong> - являются более мощной версией synchronized-блока. Основные интерфейсы замков — <code>java.util.concurrent.locks.Lock</code> и <code>ReadWriteLock</code>, а наиболее полезные классы — <code>ReentrantLock</code> и <code>ReentrantReadWriteLock</code>.</p>
<ul>
<li>Пример создания замка:<pre><code class="language-Java">private static final Lock lock = new ReentrantLock();
lock.lock();
try {
  // критическая секция
} 
finally { 
  lock.unlock(); 
}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Пулы потоков</strong> - это набор потоков, которым можно передавать какие-либо задачи (например, Runnable) на выполнение. </p>
<ul>
<li>Создание потока — дорогая операция, и часто большинство задач выполняются недолго. Поэтому имеет смысл переиспользовать уже созданные потоки для  различных задач. </li>
<li>Пример создания пула потоков:<pre><code class="language-Java">Executor executor = Executors.newFixedThreadPool(4);
executor.execute(() -&gt; /* ... */ );
executor.execute(new Runnable() {
  @Override public void run() { /* ... */ } 
});
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Жизненный цикл потока</strong>. Поток проходит через несколько стадий своего жизненного цикла:</p>
<ul>
<li>New - новый поток начинает свой жизненный цикл с изначального состояния. Он остается в нем до тех пор, пока программа не запустит его.</li>
<li>Runnable - после того, как поток создался, его надо запустить, в связи с чем, он перейдет в данное состояние. Поток в таком состоянии уже выполняет свои функции.</li>
<li>Waiting - иногда переходы между потоками занимают некоторое время, во время которого поток находится в таком состоянии, до тех пор, пока другой поток не переведет его в состояние runnable.</li>
<li>Timed waiting - runnable поток может установить время ожидания для какого-то события, после чего перейдет в данное состояние. Он перейдет обратно в runnable только после того, как истечет указанное время, или если событие, которого он ждет, произойдет.</li>
<li>Terminated - runnable поток завершается после выполнения своих функций (или его завершают) и переходит в данное состояние.</li>
<li>Диаграмма жизненого цикла потока:
<img src="http://www.tutorialspoint.com/java/images/Thread_Life_Cycle.jpg" alt="Диаграмма жизненого цикла потока"></li>
</ul>
</li>
<li><p><strong>Приоритет</strong> - каждый поток имеет приоритет, который помогает операционной системе распознавать порядок в котором потоки будут работать: <code>MIN_PRIORITY</code>, <code>NORM_PRIORITY</code>, <code>MAX_PRIORITY</code>.</p>
</li>
</ol>
<hr>
<h3>8. Коллекции</h3><ol>
<li><p><strong>Массив</strong>. Массивы встроены в язык и довольно производительны; они часто служат основой других коллекций.</p>
</li>
<li><p><strong>Интерфейс <code>Collection&lt;T&gt;</code></strong> является базовым интерфейсом для линейных коллекций. Он предоставляет основные операции, общие для всех коллекций.</p>
<ul>
<li>Данный интерфейс предоставляет следующие методы: <code>add()</code>, <code>addAll()</code>, <code>clear()</code>, <code>contains()</code>, <code>containsAll()</code>, <code>equals()</code>, <code>hashCode()</code>, <code>isEmpty()</code>, <code>iterator()</code>, <code>remove()</code>, <code>removeAll()</code>, <code>size()</code>, <code>toArray()</code>.</li>
<li>Абстрактный класс <code>AbstractCollection</code> реализует большинство методов этого интерфейса.</li>
</ul>
</li>
<li><p><strong>Интерфейс <code>List&lt;T&gt;</code></strong> является одним из наиболее часто используемых интерфейсов коллекций, который обозначает упорядоченную коллекцию. Каждый элемент списка имеет целочисленный индекс; возможно добавление и удаление элементов по индексу. Дополнительно этот интерфейс предоставляет специальный итератор <code>ListIterator&lt;T&gt;</code>, который позволяет перемещаться по списку в обе стороны и вставлять новые элементы.</p>
<ul>
<li>Данный интерфейс предоставляет следующие методы: <code>get()</code>, <code>indexOf()</code>, <code>lastIndexOf()</code>, <code>listIterator()</code>, <code>set()</code>, <code>subList()</code>.</li>
<li>Абстрактный класс <code>AbstractList</code> наследуется от <code>AbstractCollection</code> и реализует большинство методов <code>List</code> интерфейса.</li>
<li>Абстрактный класс <code>AbstractSequentialList</code> наследуется от <code>AbstractList</code> и реализует большинство методов <code>List</code> интерфейса с упором на последовательный, чем на случайный доступ к элементам.</li>
</ul>
</li>
<li><p><strong>Реализация <code>ArrayList&lt;T&gt;</code></strong> используется чаще всего в интерфейсе <code>List</code>. По сути является реализацией списка на основе массива. Кроме того, <code>ArrayList</code> очень эффективно использует память, и операции, основанные на доступе по индексу (сортировка, перемешивание, бинарный поиск и т.д.), выполняются быстро.</p>
<ul>
<li>Данная реализация предоставляет следующие методы: <code>ensureCapacity()</code>, <code>removeRange()</code>, <code>trimToSize()</code>, <code>clone()</code>.</li>
</ul>
</li>
<li><p><strong>Реализация <code>LinkedList&lt;T&gt;</code></strong> используется гораздо реже. Является реализацией списка на основе двусвязного списка. <code>LinkedList</code> эффективнее при вставке/удалении элементов в начале или конце и при вставке/удалении в середине после итерации до нужного места. Также <code>LinkedList</code> потребляет значительно больше памяти, чем <code>ArrayList</code>.</p>
<ul>
<li>Данная реализация предоставляет следующие методы: <code>addFirst()</code>, <code>addLast()</code>, <code>clone()</code>, <code>getFirst()</code>, <code>getLast()</code>, <code>removeFirst()</code>, <code>removeLast()</code>.</li>
</ul>
</li>
<li><p><strong>Интерфейс <code>Set&lt;T&gt;</code></strong> предоставляет абстракцию математического множества, т.е. неупорядоченную коллекцию, не содержащую одинаковых элементов. Из-за неупорядоченности элементы множества нельзя получить по их индексу, поэтому для множеств не имеет смысла сортировка и перемешивание элементов. Однако при этом операции проверки на наличие элемента во множестве эффективнее, чем в списке.</p>
<ul>
<li>Данный интерфейс предоставляет следующие методы: <code>isEmpty()</code>.</li>
<li>Абстрактный класс <code>AbstractSet</code> наследуется от <code>AbstractCollection</code> и реализует большинство методов <code>Set</code> интерфейса.</li>
</ul>
</li>
<li><p><strong>Интерфейс <code>SortedSet&lt;T&gt;</code></strong> является расширением <code>Set&lt;T&gt;</code>. Он предполагает наличие отношения порядка на своих элементах. Из-за этого <code>SortedSet</code> предоставляет дополнительные операции.</p>
<ul>
<li>Данный интерфейс предоставляет следующие методы: <code>clone()</code>, <code>comparator()</code>, <code>first()</code>, <code>headSet()</code>, <code>last()</code>, <code>subSet()</code>, <code>tailSet()</code>.</li>
</ul>
</li>
<li><p><strong>Реализация <code>HashSet&lt;T&gt;</code></strong> — это наиболее часто используемая реализация множества, потому что основные задачи множества она выполняет наиболее эффективно. HashSet основан на <code>HashMap</code>. Поэтому, в частности, для использования <code>HashSet</code> необходима правильная реализация методов <code>equals()</code> и <code>hashCode()</code>.</p>
<ul>
<li>Данная реализация наследуется от <code>AbstractSet</code>.</li>
<li>Данная реализация предоставляет следующие методы: <code>clone()</code>.</li>
</ul>
</li>
<li><p><strong>Реализация <code>LinkedHashSet&lt;T&gt;</code></strong> объединяет множество на основе хеш-таблицы и связный список. Эффективность всех операций на нём та же, что и у <code>HashSet</code>, но порядок итерации по нему не псевдослучаен, а соответствует порядку добавления элементов в это множество. <code>LinkedHashSet</code> основан на <code>LinkedHashMap</code> и наследует <code>HashSet</code>, поэтому для него также справедливы условия на методы <code>equals()</code> и <code>hashCode()</code> у элементов.</p>
<ul>
<li>Данная реализация наследуется от <code>HashSet</code>.</li>
</ul>
</li>
<li><p><strong>Реализация <code>TreeSet&lt;T&gt;</code></strong> — это множество, основанное на <code>TreeMap</code>. Оно реализует интерфейс <code>SortedSet&lt;T&gt;</code>, и в нём могут храниться только элементы, на которых задано отношение порядка. Класс <code>TreeSet</code> основан на <code>TreeMap</code>, и поэтому все операции над элементами имеют логарифмическую сложность. Это хуже, чем у <code>HashSet</code>, поэтому TreeSet используется только тогда, когда необходимо так или иначе сортировать элементы множества.</p>
<ul>
<li>Данная реализация наследуется от <code>AbstractSet</code>.</li>
<li>Данная реализация предоставляет следующие методы: <code>clone()</code>, <code>comparator()</code>, <code>first()</code>, <code>last()</code>, <code>headSet()</code>, <code>subSet()</code>, <code>tailSet()</code>.</li>
</ul>
</li>
<li><p><strong>Интерфейс <code>Queue&lt;T&gt;</code></strong> представляет собой контейнер, в который можно добавлять элементы и доставать их оттуда. Релизации <code>Queue&lt;T&gt;</code> могут ограничивать максимальное количество элементов в коллекции. Поэтому <code>Queue&lt;T&gt;</code> предоставляет два набора методов для указанных операций. Первый набор в граничных ситуациях выбрасывает исключение, а второй — возвращает специальное значение (null или boolean).</p>
<ul>
<li>Абстрактный класс <code>AbstractQueue</code> наследуется от <code>AbstractCollection</code> и реализует большинство методов <code>Queue</code> интерфейса.</li>
<li>Данный интерфейс предоставляет следующие методы: <code>offer()</code>, <code>peek()</code>, <code>poll()</code>.</li>
</ul>
</li>
<li><p><strong>Интерфейс <code>Deque&lt;T&gt;</code></strong> обозначает дек, структуру данных, являющуюся одновременно стеком и очередью. В дек можно добавлять и удалять элементы с двух сторон.</p>
<ul>
<li>Данный интерфейс предоставляет следующие методы: <code>offer()</code>, <code>peek()</code>, <code>poll()</code>, <code>addFirst()</code>, <code>addLast()</code>, <code>descendingIterator()</code>, <code>element()</code>, <code>getFirst()</code>, <code>getLast()</code>, <code>offerFirst()</code>, <code>offerLast()</code>, <code>peekFirst()</code>, <code>peekLast()</code>, <code>pollFirst()</code>, <code>pollLast()</code>, <code>pop()</code>, <code>push()</code>, <code>removeFirst()</code>, <code>removeFirstOccurrence()</code>, <code>removeLast()</code>, <code>removeLastOccurrence()</code>, <code>size()</code>.</li>
</ul>
</li>
<li><p><strong>Реализация <code>ArrayDeque&lt;T&gt;</code></strong> с помощью массива - наиболее удобная и эффективная.</p>
<ul>
<li>Данная реализация наследуется от <code>AbstractCollection</code> и реализует интерфейс <code>Deque</code>.</li>
<li>Данный интерфейс предоставляет следующие методы: <code>isEmpty()</code>, <code>clone()</code>, <code>toArray()</code>.</li>
</ul>
</li>
<li><p><strong><code>java.util.Arrays</code></strong> предоставляет статические методы для манипуляций с массивами, такие как: <code>binarySearch()</code>, <code>equals()</code>, <code>fill()</code>, <code>sort()</code>.</p>
</li>
<li><p><strong><code>java.util.Collections</code></strong> предоставляет статические методы для манипуляций с массивами, такие как: <code>binarySearch()</code>, <code>fill()</code>, <code>sort()</code>, <code>copy()</code>, <code>enumeration()</code>, <code>indexOfSubList()</code>, <code>lastIndexOfSubList()</code>, <code>list()</code>, <code>max()</code>, <code>min()</code>, <code>nCopies()</code>, <code>replaceAll()</code>, <code>reverse()</code>, <code>reverseOrder()</code>, <code>rotate()</code>, <code>shuffle()</code>, <code>singleton()</code>, <code>singletonList()</code>, <code>singletonMap()</code>, <code>swap()</code>, <code>synchronizedCollection()</code>, <code>synchronizedList()</code>, <code>synchronizedMap()</code>, <code>synchronizedSet()</code>, <code>synchronizedSortedMap()</code>, <code>synchronizedSortedSet()</code>, <code>unmodifiableCollection()</code>, <code>unmodifiableList()</code>, <code>unmodifiableMap()</code>, <code>unmodifiableSet()</code>, <code>unmodifiableSortedMap()</code>, <code>unmodifiableSortedSet()</code>.</p>
</li>
<li><p>Иерархия коллекций<br><img src="https://i.gyazo.com/c728629e97972ba7d715d23c2f3e7b51.png" alt="Иерархия коллекций"></p>
</li>
</ol>
<hr>
<h3>9. Мапы</h3><ol>
<li><p><strong>Интерфейс <code>Map&lt;K, V&gt;</code></strong> представляет абстракцию ассоциативного массива (словаря, отображения). Он хранит пары (ключ, значчение) и поддерживает три основные операции: <code>put</code>, <code>get</code>, <code>remove</code>. При этом предполагается, что ключи уникальны. Если операция <code>put</code> вызывается с ключом, который уже есть в ассоциативном массиве, соответствующее значение будет заменено.</p>
<ul>
<li>Абстрактный класс <code>AbstractMap</code> реализует большинство методов <code>Map</code> интерфейса.</li>
<li>Данный интерфейс предоставляет следующие методы: <code>clear()</code>, <code>containsKey()</code>, <code>containsValue()</code>, <code>entrySet()</code>, <code>equals()</code>, <code>get()</code>, <code>hashCode()</code>, <code>isEmpty()</code>, <code>keySet()</code>, <code>put()</code>, <code>putAll()</code>, <code>remove()</code>, <code>size()</code>, <code>values()</code>.</li>
</ul>
</li>
<li><p><strong>Интерфейс <code>SortedMap&lt;K, V&gt;</code></strong> обозначает словарь, в котором на ключах задано отношение порядка. Аналогично <code>SortedSet&lt;T&gt;</code>, <code>SortedMap&lt;K, V&gt;</code> предоставляет дополнительные операции. Предполагается, что эти операции словарь способен выполнять эффективно.</p>
<ul>
<li>Данный интерфейс наследуется от <code>Map</code> интерфейса.</li>
<li>Данный интерфейс предоставляет следующие методы: <code>comparator()</code>, <code>firstKey()</code>, <code>headMap()</code>, <code>lastKey()</code>, <code>subMap()</code>, <code>tailMap()</code>.</li>
</ul>
</li>
<li><p><strong>Реализация <code>HashMap&lt;K, V&gt;</code></strong> - словарь на основе хеш-таблицы. Из-за этого все операции над <code>HashMap</code> очень эффективны. HashMap реализован как хеш-таблица на основе цепочек. Внутри он содержит массив «корзин», каждая из которых является односвязным списком. Поэтому элементы словаря должны корректно реализовывать методы <code>equals()</code> и <code>hashCode()</code>. Для идеальной хеш-функции эффективность операций константная.</p>
<ul>
<li>Данная реализация наследуется от <code>AbstractMap</code> и реализует <code>Map</code> интерфейс.</li>
<li>Данная реализация предоставляет следующие методы: <code>clone()</code>.</li>
</ul>
</li>
<li><p><strong>Реализация <code>LinkedHashMap&lt;K, V&gt;</code></strong> объединяет хеш-таблицу и связный список. Используется, когда необходимо сохранять порядок добавления элементов в словарь. Помимо структуры хеш-таблицы, <code>LinkedHashMap</code> добавляет новые записи в связный список. С помощью этого можно восстановить порядок добавления элементов. Эффективность операций у <code>LinkedHashMap</code> та же, что и у обычного <code>HashMap</code>, но из-за дополнительной структуры на элементах потребление памяти выше.</p>
<ul>
<li>Данная реализация наследуется от <code>HashMap</code> и реализует <code>Map</code> интерфейс.</li>
<li>Данная реализация предоставляет следующие методы: <code>removeEldestEntry()</code>.</li>
</ul>
</li>
<li><p><strong>Реализация <code>TreeMap&lt;K, V&gt;</code></strong> — это реализация словаря на основе красно-чёрного бинарного дерева поиска (дерево образуют ключи). Эта структура требует отношения порядка на элементах, поэтому <code>TreeMap</code> реализует интерфейс <code>SortedMap</code>. Поскольку внутри <code>TreeMap</code> используется бинарное дерево, то все операции имеют логарифмическую эффективность.</p>
<ul>
<li>Данная реализация наследуется от <code>AbstractMap</code> и реализует <code>SortedMap</code> интерфейс.</li>
<li>Данная реализация предоставляет следующие методы: <code>clone()</code>.</li>
</ul>
</li>
<li><p>Иерархия мапов<br> <img src="https://i.gyazo.com/edfb3a3797946a21747880fcac1507ba.png" alt="Иерархия мапов"></p>
</li>
</ol>
<hr></div></div></section><section class="vibrant centered"><div><h4>© Copyright 2016 <a href="https://github.com/Praytic">Chernogorov Vladislav</a></h4></div></section></body><script src="//ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/highlight.min.js"></script><script src="/js/layout.js"></script><script type="text/javascript">hljs.initHighlightingOnLoad();</script></html>